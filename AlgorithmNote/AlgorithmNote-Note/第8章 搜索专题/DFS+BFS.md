# 《算法笔记上机训练实战指南》习题报告

### 作者：wuyangjun

### 时间：2019/8/10

### 主题：DFS+BFS

---



[TOC]

## DFS

### [A1103 Integer Factorization](https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224)

#### 思路

​		典型的DFS应用，问题等价于在[1,N]中选出K个数，这K个数的P次方之和为N，在满足条件的序列中选出K个数之和最大的方案，若还存在多个方案，选择序列非升序排列时字典序大的方案。因此，问题转换为如何在[1,N]搜索长度为K的子序列，只要能找到所有长度为K的子序列，那么只需验证其是否满足条件，在满足条件中找出最终答案。

​		步骤 1：为了不超时，且N不超过400，因此将[1,21]的P次方的结果先计算好并保存到数组powP中，这样dfs搜索时可以直接查表，时间复杂度为O(1)，若调用库函数pow则需在类型转换花费许多时间，导致超时。

​		步骤 2：若从大到小搜索可避免字典序的问题，但这里解释从小到大搜索，需要考虑字典序比较问题。dfs函数用于从[1,N]选择若干个数（可重复选取），是他们P次方和为N。于是对每个数x，均有选和不选两条路，从而进入相应子递归。dfs的参数必须有：

+ idx：当前需取舍的数
+ nowK：当前已选择了几个数，用于边界和剪枝
+ sumP：当前选中的所有数的P次方，用于边界和剪枝
+ sum：当前选中的所有数的和，便于最优化选择

​		因此dfs接口如下：

```c++
void dfs(int idx, int nowK, int sum, int sumP) {}
```

​		此外，还需要开一个vector<int>ans，用来存放最优的底数序列，而用一个vector<int>tmp来存放当前选中的底数组成的临时序列。

​		步骤 3：搜索如何停止呢？首先，若nowK=K并且sumP==N，说明找到一个满足条件的序列，保存在tmp中，此时为了处理多方案的情况，需判断当前底数之和sum是否比全局记录的最大底数之和maxSum更大，若是，则更新maxSum和ans。若sum等于maxSum，需要通过比较二者按非降序排列的字典序，将较大者作为ans。除此之外，其边界和剪枝为`sumP + powP[idx] > N || nowK >= K`，二者满足其一，说明后续不可能产生答案，返回即可。

​		步骤 4：在递归未到达边界时，对于当前数idx有选于不选两条路，若选，由于每个数字可重复，因此下一步还是对idx的选择，当由于已选择了idx，需要把idx加入当前序列tmp中，同时更新另外3个参数，因此往`dfs(idx, nowK + 1, sum + idx, sumP + powP[idx])`这条分支前进；若不选，问题转换为对idx+1进行选择，将之前选择时存储的idx从tmp中删除，此时nowK、sumP、sum均不变，因此往`dfs(idx + 1, nowK, sum, sumP)`这条分支前进。

#### 注意点

+ 边界+剪枝：`sumP + powP[idx] > N || nowK >= K`这里两种情况都需考虑，否则样例5过不了。
+ 不可直接用库函数pow，导致超时，可先将22以内的P次方先计算出来并保存到数组中，之后直接查表即可。

#### C++

```c++
/*
 * @Author: wuyangjun
 * @Date: 2019-08-10 09:35:52
 * @LastEditTime: 2019-08-10 12:34:04
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
vector<int> tmp, ans; //存放中间序列和结果序列
int maxSum = -1; //最大P次方和
int N, K, P;
int powP[22]; //P次方表
// 初始化1~21的P次方表
void initPow() {
    for(int i = 1; i < 22; i ++) {
        int sum = 1;
        for(int j = 0; j < P; j ++) {
            sum *= i;
        }
        powP[i] = sum;
    }
}
void print(vector<int> ans) {
    if(ans.empty()) printf("Impossible\n");
    else {
        printf("%d = ", N);
        for(int i = ans.size() - 1; i >= 0; i --) {
            printf("%d^%d%s", ans[i], P, i == 0 ? "\n" : " + ");
        }
    }
}
// 比较字典序
int cmpVec(vector<int>& a, vector<int>& b) {
    for(int i = a.size() - 1; i >= 0; i --) {
        if(a[i] < b[i]) return -1;
        if(a[i] > b[i]) return 1;
    }
}
// idx：取值[1,N] nowK:当前已选取个数 sum：当前已选取序列和 sumP：当前已选序列P次方和
void dfs(int idx, int nowK, int sum, int sumP) {
    // K个数的P次方和为N
    if(nowK == K && sumP == N) {
        if(sum > maxSum) { //序列和大者优先
            maxSum = sum;
            ans = tmp;
        }
        else if(sum == maxSum) {  // 选排序后字典序大者
            if(cmpVec(ans, tmp) == -1) ans = tmp;
        }
        return;
    }
    // 已遍历所有取值、当前已选个数大于K、K个数的P次方和大于N
    if(sumP + powP[idx] > N || nowK >= K) return; //边界+剪枝
    tmp.push_back(idx); //选
    dfs(idx, nowK + 1, sum + idx, sumP + powP[idx]); //idx不加1，可能重复选取
    tmp.pop_back(); //不选
    dfs(idx + 1, nowK, sum, sumP);
}
int main() {
    scanf("%d %d %d", &N, &K, &P);
    initPow();
    dfs(1, 0, 0, 0);
    print(ans);
    return 0;
}
```



## BFS

### [A1091 Acute Stroke](https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072)

#### 思路

​		题意是给定一个三维数组，数组元素取值为0或1。对任意一个为1的点，其上下左右前后的元素称作它的相邻元素。若干个相邻的1称为块，类似于图论中的连通分支。若某个块中1的个数不低于T，那么称其为“卒中核心块”。现要求解所有“卒中核心块”中1的个数之和。

​		问题等价于求解所有节点数大于T的连通分支的节点数之和。因此可用BFS遍历所有连通分支，即所谓块，若该块节点数小于T，返回0，表示不无效；否则，返回节点数。那么如何使用BFS？这个好办，套用模板即可。但此题有两个小技巧：

+ 使用三维数组存储数据，为了迁就坐标的使用习惯，最高位不存放层数，而是按照习惯依次存放x，y，z。定义好三维数组的结构，读入数据是按多个二维数组读入，使用时也要以同样方式，即怎么存就怎么用。

```c++
int pixel[1230][130][61] = {0}; //3维数组(x,y,z) 而不是(z,x,y):pixel[61][1230][61]
```

+ 定义三个维度的增量数组，简化代码，竖着看每一列表示一个方向

```c++
int X[] = {0, 0, 0, 0, 1, -1};
int Y[] = {0, 0, 1, -1, 0, 0};
int Z[] = {1, -1, 0, 0, 0, 0};
```

​		这样就可以通过for循环来枚举6个方向，以确定与当前坐标`(node.x,node.y,node.z)`相邻的6个方向。

```c++
for(int i = 0; i < 6; i ++) {
    newNode.x = node.x + X[i];
    newNode.y = node.y + Y[i];
    newNode.z = node.z + Z[i];
}
```

#### 注意点

+ inq表示节点**是否已经入队**，若表示**是否被访问**，则有可能存在重复入队的可能，造成计算量大大增加。因此，每次节点入队，需要立即给相应的inq赋true，表示该节点已入队。
+ 如何统计一个连通分支（块）的节点数？由于一个块内的所有点都会**入队出队一次**，但第一个节点在循环外先入队，而所有的节点均在while循环内出队，为了代码的简洁，统一选择在出队时统计节点个数。
+ 注意数据读入数组、访问数组元素、越界判断时应与三维数组的结构相一致。否则会出现段错误。

#### C++

```c++
/*
 * @Author: wuyangjun
 * @Date: 2019-08-10 16:52:24
 * @LastEditTime: 2019-08-10 17:55:47
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
// 像素点坐标
struct Node {
    int x, y, z;
}node, newNode;
int pixel[1230][130][61] = {0}; //3维数组(x,y,z)
bool inq[1230][130][61] = {0}; //记录是否入队
int M, N, L, T; //行，列，层，阈值
// x,y,z增量，控制6个方向
int X[] = {0, 0, 0, 0, 1, -1};
int Y[] = {0, 0, 1, -1, 0, 0};
int Z[] = {1, -1, 0, 0, 0, 0};
bool judge(int x, int y, int z) {
    // 越界
    if(x >= M || x < 0 || y >= N || y < 0 || z >= L || z < 0) return false;
    // 0或已在队列
    if(pixel[x][y][z] == 0 || inq[x][y][z] == true) return false;
    return true;
}
int bfs(int x, int y, int z) { 
    int cnt = 0; //统计1的个数
    queue<Node> q;
    node.x = x;
    node.y = y;
    node.z = z;
    q.push(node); //首节点入队
    inq[node.x][node.y][node.z] = true; //入队立刻标记
    while(!q.empty()) {
        node = q.front();
        q.pop();
        cnt ++; //出队统计1的个数
        // 遍历6个方向
        for(int i = 0; i < 6; i ++) {
            newNode.x = node.x + X[i];
            newNode.y = node.y + Y[i];
            newNode.z = node.z + Z[i];
            if(judge(newNode.x, newNode.y, newNode.z)) {
                q.push(newNode);
                inq[newNode.x][newNode.y][newNode.z] = true; //入队立刻标记
            }
        }
    }
    // 达到阈值T才有效
    if(cnt >= T) return cnt;
    else return 0;
}
int main() {
    scanf("%d %d %d %d", &M, &N, &L, &T);
    int sum = 0; //有效1的总数
    // 怎么存储就怎么访问
    for(int z = 0; z < L; z ++) {
        for(int x = 0; x < M; x ++) {
            for(int y = 0; y < N; y ++) {
                scanf("%d", &pixel[x][y][z]);
            }
        }
    }
    // 遍历每个点
    for(int z = 0; z < L; z ++) {
        for(int x = 0; x < M; x ++) {
            for(int y = 0; y < N; y ++) {
                if(pixel[x][y][z] == 1 && inq[x][y][z] == false) {
                    sum += bfs(x, y, z);
                }
            }
        }
    }
    printf("%d\n", sum);
    return 0;
}
```



## 总结

### 模板概述

​		有组织的搜索思想一般叫做回溯法，回溯法在于它拥有剪枝技巧，即在未达到边界前由于事实可知无需再进入子递归，可直接返回。DFS和BFS则是具体的两种搜索思想，可看成回溯法这个类的的两个对象。根据两种思想的特性通常使用递归实现DFS（用栈也行，不过麻烦些），用队列实现BFS，DFS较为灵活且难以调试，同时剪枝好坏直接影响时间复杂度。而BFS使用STL的队列实现，拥有套路模板，较为简单。其常用模板如下：

```c++
returnType BFS(dataType s) {
    queue<dataType> q; //定义队列q
	q.push(s); //起点s入队
    inq[s] = true; //标记为已入队
    while(!q.empty()) { //队列非空
        dataType top = q.front(); //取出队首元素top
        visit(top); //访问队首元素，可谓任何操作，例如输出、计数等等
        q.pop(); //队首元素出队
        //对于top所有相邻且未入队的节点入队，也可以标记其层数
        for(adjcentNode:adjcent(top)) {
         	q.push(adjcentNode); //入队
            inq[adjcentNode] = true; //标记已入队
        }
    }
}
```

​		DFS过于灵活，无法总结出通用模板，只能靠经验积累和不断思考总结，不过也有以下三大设计要素：

+ **接口设计**：分析问题，建立模型，一般可用**运筹学方法建立目标与约束**，从而找到必备参数。好的接口设计可大大降低编码复杂度。
+ **边界+剪枝**：接口设计好，通过问题分析中的约束，可知不满足约束时即为边界，也可利用约束进行剪枝，剪枝设计的好坏，直接影响时间复杂度，所以需要慎重。
+ **递归式**：未达边界或剪枝状态时，需要根据问题分析找到通往子问题的桥梁，即岔道口是什么。这一步一般和动态规划一样较为难找，状态复杂时需仔细分析。这一步直接关系答案是否正确。

### DFS题型分析

#### 幂集求解（所有子序列）

​		常见DFS类型题：给定长度为n的集合A={1,2...,n}，求出它的幂集，即所有的子集（子序列）。这类搜索其实就是穷举所有情况，保留符合条件的集合。思路如下：

+ **接口设计**：`void dfs(int idx)`，其中idx表示当前元素。
+ **边界**：当idx==n+1时表示已经对每个元素取舍做了定夺，可以输出取舍结果。这里无需剪枝，因为要输出所有情况。
+ **递归式**：每个元素均有选和不选两种情况。选的话记录当前元素，进入下一个元素取舍；不选的话弹出刚才记录的元素，等价于不选当前元素，进入下一个元素取舍。

```c++
/*
 * @Author: wuyangjun
 * @Date: 2019-08-10 19:45:33
 * @LastEditTime: 2019-08-10 20:06:59
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
int N;
vector<int> ans;
void print() {
    if(ans.empty()) printf("NULL SET\n");
    else {
        for(int i = 0; i < ans.size(); i ++) {
            printf("%d%s", ans[i], i == ans.size() - 1 ? "\n" : " ");
        }
    }
}
void dfs(int idx) {
    if(idx == N + 1) {
        print();
        return;
    }
    ans.push_back(idx);
    dfs(idx + 1); //选
    ans.pop_back();
    dfs(idx + 1); //不选
}
int main() {
    N = 4;
    dfs(1);
    return 0;
}
```

#### 幂集衍生问题

##### 1、长度为K的子序列集合

​		只要能求出序列A的幂集，那么通过**剪枝**就可以轻松求出A的**长度为K**（K<=N）的子序列集合B。这里在幂集求解基础上增加了子序列长度为K的约束，**增加约束**一般在编程中是**增加接口参数**和**剪枝条件**。增加了剪枝的本质就是从幂集中挑出长度为K的集合，因此，只需要在幂集求解基础上稍作修改即可。思路如下：

+ **接口设计**：`void dfs_K(int idx, int nowK)`，在幂集求解基础上增加了nowK，用于记录当前已选择的元素个数，以满足**长度为K的新约束**。
+ **边界+剪枝**：这里的边界和幂集求解一样，都是`idx == N+1`，然而这里有约束：仅求长度为K的子序列。因此，根据约束可设计剪枝`nowK == K`时打印输出，立刻返回，不再向子问题递归。
+ **递归式**：此处和幂集求解一样，每个元素都有选和不选两种情况。幂集只需要考虑对idx的影响即可，但由于这里接口参数增加了nowK，所以两个分支还需要考虑对它的影响。选的话nowK需要加1，表示已选数目增加1；不选的话nowK不变，表示已选数目不变。

```c++
// idx：当前元素 nowK：已选个数
void dfs_K(int idx, int nowK) {
    if(nowK == K) { //满足条件，输出并返回，剪枝
        print();
        return;
    }
    if(idx == N + 1) return; //边界
    ans.push_back(idx);
    dfs_K(idx + 1, nowK + 1); //选
    ans.pop_back();
    dfs_K(idx + 1, nowK); //不选
}
```

##### 2、和为X+长为K的子序列集合

​		至此已经能求出所有长度为K的子序列集合B，在此基础上加强约束，要求每个子序列的和必须为X。本质是从集合B中选出和值为X的所有序列。同上，加强约束一般就是增加接口参数和剪枝条件。思路如下：

+ **接口设计**：`void dfs_K_X(int idx, int nowK, int sum)`，增加一个参数sum表示当前序列的和，以满足子序列和为X的新增约束。
+ **边界+剪枝**：增加了约束，自然也要增加相应的边界和剪枝，才能选出符合条件的序列，在上个问题的原有条件剪枝`nowK==K`上，增加满足要求的条件剪枝`sum == X`。同时，在上个问题的原有边界增加新的剪枝条件`sum >= X`，这里体现了剪枝的灵活性，艺术性，直接影响时间复杂度。
+ **递归式**：与之前的问题一致，每个元素仅有选与不选两种情况，由于增加了约束导致增加了接口参数sum，因此在上个问题的基础上，在递归式中需考虑对sum的影响。选当前元素，sum加上当前元素idx；不选，sum则保持不变。

```c++
// idx：当前元素 nowK：已选个数 sum：已选元素总和
void dfs_K_X(int idx, int nowK, int sum) {
    if(nowK == K && sum == X) { //添加边界+剪枝条件
        print();
        return;
    }
    if(idx == N + 1 || sum >= X) return; //添加剪枝条件
    ans.push_back(idx);
    dfs_K_X(idx + 1, nowK + 1, sum + idx); //选
    ans.pop_back();
    dfs_K_X(idx + 1, nowK, sum); //不选
}
```

##### 3、平方和最大+和为X+长度为K的子序列（假设唯一）

​		在第二个问题上再次加强约束：选出其中平方和最大的序列，这里假设满足该条件的序列唯一。本质是从满足问题2的序列集合中选出平方和最大的那个序列，注意，只有一个序列，而不像之前问题是一个集合。有了之前的经验，比较容易知道如何增加修改。

+ **接口设计**：在**问题2**的基础上增加一个`sumSquare`表示当前已选元素的平方和，以此来满足新增约束。
+ **边界+剪枝**：由于这个约束要求必须在**问题2的解集合**中选出最优解，所以子序列的搜索不应该增加剪枝和边界条件，反而当找到满足问题2的解时，选出其中较大者，保存到最优解中。
+ **递归式**：由于接口增加了新参数`sumSquare`，在问题2的基础上，需增加对新参数的考虑。

```c++
int N, K, X, maxSumSquare = -1; //最大平方和
vector<int> ans, tmp; //tmp临时存放序列
// idx：当前元素 nowK：已选个数 sum：已选元素总和 sumSquare：已选元素平方和
void dfs_K_X_MaxSumSquare(int idx, int nowK, int sum, int sumSquare) {
    if(nowK == K && sum == X) { //满足条件
        if(sumSquare > maxSumSquare) { //最优选择，maxSumSquare为全局最大平方和
            maxSumSquare = sumSquare;
            ans = tmp;
        }
        return;
    }
    if(idx == N + 1 || sum >= X) return; //剪枝边界
    tmp.push_back(idx); //存到中间容器
    dfs_K_X_MaxSumSquare(idx + 1, nowK + 1, sum + idx, sumSquare + idx * idx); //选
    tmp.pop_back();
    dfs_K_X_MaxSumSquare(idx + 1, nowK, sum, sumSquare); //不选
}
```

#### 小结

​		从没有约束的幂集求解问题开始，我们学会了如何求解所有的子序列。在此基础上，根据不断增加的新约束，我们对dfs三要素**接口设计、边界剪枝和递归式**做出相应调整，以满足新约束。

​		我们在幂集求解的基础上依次增加了**子序列长度为K**、**子序列和为X**和**子序列平方和最大**三个约束，这三个约束具有累加效果，循序渐进，每次面对新的约束（需求），我们总是在**之前的基础**上，通过**分析新问题**得到**新约束的抽象的表示**，即在**接口设计**中添加**新的参数**。其次，需谨慎考虑新约束**是否带来的新的隐含边界和剪枝条件**，若其带来新边界（剪枝是特殊边界），则需添加适当的边界和剪枝条件，以获得良好的时间复杂度。最后考虑递归式，若接口有新的参数加入，那么递归式必须考虑到对新参数的影响。

​		可见，在幂集基础上稍作修改就能解决许多衍生问题，可谓万变不离其宗。如下展示了通用的解题思路，从原问题出发，必须已知原问题的解法，正如必须掌握幂集求法，此乃基础设施，少了它寸步难行。此时在原有问题基础上新增一些约束或限制条件就构造出了新问题，假设你已掌握原问题的解法，此刻，你必须结合**增加约束1**并利用映射、对比和启发等手段，推导出原解法到新解法间的**增加约束2**，找到它，就等于找到了从原解法通向新解法的桥梁。落实到dfs就是通过分析新增约束，依次考查新增约束对dfs三要素即**接口设计、边界剪枝和递归式**的影响，这三要素即是此处的桥梁，因此，这类问题只要遇到新约束，就往桥梁即三要素边上靠。

```
原问题  --（增加约束1）-- > 新问题 
  |			  |
(已知)	(根据约束1找到原解法到新解法的约束2，即映射)
  ↓	          ↓
原解法  --（增加约束2）-- > 新解法
```

​		掌握了这种学习思路，等于朝举一反三更进一步，正如阿基米德所说：给我一个支点，我能撬动地球！这里面少了一样极其重要且常常被忽视的东西，即杠杆。在学校中老师大多只能教授一个个零散的最简单的原问题解法，通常我们也是被动吸收这些原问题，而常常忽略了思考问题间的联系，才导致学习效率低下，不成系统，无法融汇贯通。

​		同时这句话具有巨大的启发：最基础的原问题的解法就是支点，找到问题间的联系就是手中的杠杆。仅有支点却无杠杆只能在原地打转，正如会许多最基础的问题解法而不知变通，进步缓慢，标准填鸭式教育的痛点；仅有杠杆而不知支点就似无头苍蝇般盲目做无用功，停留在表面而不知其根源，正如掌握了一类问题间的联系与规律，但却是死记硬背，不知其所以然，不知最简单的问题如何解决，典型的纸上谈兵，没有落实到实际上。只有支点和杠杆相结合，方能释放出震天动地的能量，举一反三都是其附带品，更重要的是令学习更加系统化，学习效率大幅提升，更能融汇贯通，应用所学。

### 心得体会

​		进入搜索专题明显感觉到问题变难了，不那么容易思考同时调试更加困难，本章虽然只有两道题，但总结分析的篇幅早已远远超过从前的报告。毋庸置疑，在不断的思考，猜测，验证，归纳的过程中写出的总结，不仅加深自身对两种搜索技术的理解，而且锻炼了总结归纳与表述的能力，收获颇丰。

​		深刻意识到写文章和写程序一样，不可能什么都想好才动笔写，一定是借助语言这个工具来帮助思考，边写边改边想，否则最开始的时候可能根本不知道该写什么，正如不动手写代码就不知道如何写，只要动手写就会促进思考，一思考就发现了问题，一开始解决问题就发现了许多规律，进而有了许多感悟，以此催促继续发现、思考、归纳。

​		这是一个螺旋式上升的过程，不得不说，我很赞同台湾作家阿城的看法，他认为写小说主题和题材不是最重要的，关键在于过程，他可以将一个题材写上一千遍，但每次写都不一样，陶醉于每一次写作的变化过程。好的小说不是在于好题材，而在于他将每一个过程都落实到位，叠加起来就给人一种平实真诚的感受，从这个角度来看是好的过程铸就了好的小说。

​		同理，写程序写文章都应该注重变化过程，体会那种从0开始建造一个世界的美妙，今天的总结就是从基础问题一直引申推导出一系列其它问题，方觉得这样写得文章才是具有价值的，能够碰撞出许多思维的火花，知识得到系统的深化与重构思维，将平生所学串起来，加强应用能力。

​		写程序如何快速提高？一是写完代码自个优化，二是学习他人优秀思路写法。两种方式完全适用于写文章，写完文章后自己读一遍，正确性第一，即逻辑通畅，没有语病；其次语句通畅，表达清晰，读起来朗朗上口。这需要长时间的练习，每次读自己写的文章时就可以不断找出问题，修改问题，直至较优，这样进步很快。