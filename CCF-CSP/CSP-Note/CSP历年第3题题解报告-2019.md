---
title: CSP历年第3题题解报告-2019
date: 2019-08-27 21:05:00
tags: 
	- CSP
categories: Algorithm
summary: 对csp历年第3题进行详细分析，最后总结归纳出相应解题技巧
---


# CSP历年第3题题解报告

### 作者：wuyangjun

### 时间：2019/8/27~

### 主题：大模拟

---
## [201909-3 字符画](http://118.190.20.162/view.page?gpid=T92)

### 1 思路分析

本质是二维数组**分块**遍历，辅之以字符串处理与进制转换，最后根据题目要求输出相应序列即可。数据结构如下：

```cpp
struct pixel { // 像素点
	int r, g, b;
};
vector<vector<pixel>> img, imgavr; // 原图像；小块平均值
```

核心处理步骤如下：

1. **字符串处理**

+ 采用`string(n,c)`快速构造含有n个c的字符串，如`string(3,b)=>"bbb"`。假设源串为rgb
  + `#a`：`rgb+=string(5,rgb.back())`
  + `#abc`：`rgb = "#" + string(2, rgb[1]) + string(2, rgb[2]) + string(2, rgb[3]);`

2. **进制转换**

+ **16进制字符串=》10进制数值**：`stoi(str,0,16)`表示将str转换为16进制整型数返回
+ **10进制数值=》16进制字符串**：`sprintf(str,"%X",25)`表示将整型数15转为16进制字符串`19`返回
+ **字符=》ascii的16进制**：格式化输出--`printf("\\x%02X",c)`

3. **主控输出逻辑**

注意需要**打印重置序列**的两个地方！！！以下是伪代码描述：

```pseudocode
pre表示上一次处理的小块的rgb，cur表示即将处理的小块的rgb，defaultColor={0,0,0}表示默认背景色（黑）
pre = defaultColor // 初始化为默认背景色（黑）
for (对于每一行的小块) {
	for (对于一行内的每个小块) {
        if (cur != pre) { // 不同才需要进一步处理转义序列
        	if (cur = defaultColor) 打印重置序列！！！
        	else 打印背景色转义序列
        }
        输出空格
        pre = cur // 更新pre
	}
	if (pre != defaultColor) 打印重置序列！！！
	pre = defaultColor
	输出换行
}
```

### 2 注意点

+ **（m,n)**表示图片**（宽，高）==（列，行）**，注意别把它误当成(行，列)。（p,q）同理。
+ 转义序列中`R G B`均采用**十进制**表示，如`(255,255,255)`。
  + 在其输出时，需要把**每个字符**按照**其ascii码的16进制**输出，例如`255`输出为`\x32\x35\x35`（**而不是将255这个数值转换为16进制数值`FF`然后再输出**）
  + 输出若**不足2位的需补0**，如`\n => \x0A`（**字母均为大写**）
+ 主控程序逻辑
  + 当前rgb与上一个rgb不同**且**当前rgb为默认值，使用**重置序列**
  + 每一行小块的末尾的rgb若不是默认值，需**重置序列**
  + **每一小块**必须对应输出一个**空格**；**每一行小块结尾**必须输出一个**换行**`\n`
+ 本题仅用到背景色，与前景色无关（最佳迷惑行为）

### 3 测试用例

主要针对**注意点**处设计3个**具由代表性**的测试用例，题目给出的样例不再重复

```c
输入1：=======
2 3
2 1
#101010
#010101
#0
#0
#1
#1
输出1：
\x1B\x5B\x34\x38\x3B\x32\x3B\x38\x3B\x38\x3B\x38\x6D\x20\x1B\x5B\x30\x6D\x0A\x20\x0A\x1B\x5B\x34\x38\x3B\x32\x3B\x31\x37\x3B\x31\x37\x3B\x31\x37\x6D\x20\x1B\x5B\x30\x6D\x0A

输入2：========
2 2
1 1
#010101
#0
#010101
#010101
输出2：
\x1B\x5B\x34\x38\x3B\x32\x3B\x31\x3B\x31\x3B\x31\x6D\x20\x1B\x5B\x30\x6D\x20\x0A\x1B\x5B\x34\x38\x3B\x32\x3B\x31\x3B\x31\x3B\x31\x6D\x20\x20\x1B\x5B\x30\x6D\x0A

输入3：=======
2 2
2 1
#111111
#0
#000000
#111
输出3：
\x1B\x5B\x34\x38\x3B\x32\x3B\x38\x3B\x38\x3B\x38\x6D\x20\x1B\x5B\x30\x6D\x0A\x1B\x5B\x34\x38\x3B\x32\x3B\x38\x3B\x38\x3B\x38\x6D\x20\x1B\x5B\x30\x6D\x0A
```

### 4 C++（字符串处理+进制转换+二维数组分块遍历）

```cpp
/*
 * @Author: wuyangjun 
 * @Create time: 2019-12-15 01:04:39 
 * @Last Modified time: 2019-12-15 01:04:39 
 * @Gitub: https://github.com/wyjoutstanding 
*/
#include <bits/stdc++.h>
using namespace std;
struct pixel { // 像素点
	int r, g, b;
};
vector<vector<pixel>> img, imgavr; // 原图像；小块平均值
int m, n, p, q;
string backColor = "\x1b[48;2;R;G;Bm", defaultColor = "\x1b[0m"; // 背景色；默认色
// 打印转义序列，打印默认序列时可传递任意rgb值
void output(string str, pixel p) {
	for (auto c : str) {
		int val = -1;
		char rgb[20]; string tmp;
		switch (c) {
			case 'R': val = p.r; break;
			case 'G': val = p.g; break;
			case 'B': val = p.b; break;
			default: printf("\\x%02X", c);
		}
		if (val != -1) { // 背景色序列
			sprintf(rgb, "%d", val); // 直接转为10进制字符串 !!!!不需要转为16进制再输出字符串！！！
			tmp = rgb;
			for (auto v : tmp) { // 逐个打印
				printf("\\x%02X", v);
			}
		}
	}
}
int main() {
	scanf("%d %d %d %d", &m, &n, &p, &q);
	swap(m,n); swap(p,q); // m是宽，n是高，分别对应(列，行)；因此这里做个转换
	char c_rgb[1000];
	string rgb;
	pixel tmp;
	// 1.读入并处理字符串为整型
	for (int i = 0; i < m; i ++) {
		vector<pixel> a; img.push_back(a); // 初始化
		for (int j = 0; j < n; j ++) {
			scanf("%s", c_rgb);
			rgb = c_rgb;
			if (rgb.size() == 2) rgb += string(5, rgb.back()); // #a -> #aaaaaa
			else if (rgb.size() == 4) { // #abc -> #aabbcc
				rgb = "#" + string(2, rgb[1]) + string(2, rgb[2]) + string(2, rgb[3]);
			}
			// 16进制字符串转换为10进制数值
			tmp.r = stoi(rgb.substr(1,2), 0, 16);
			tmp.g = stoi(rgb.substr(3,2), 0, 16);
			tmp.b = stoi(rgb.substr(5,2), 0, 16);
			img[i].push_back(tmp);
		}
	}
	int m1 = m / p, n1 = n / q;
	// 2.分块遍历（每块大小：p*q)，计算每小块的平均值
	for (int i = 0; i < m1; i ++) {
		vector<pixel> a;
		imgavr.push_back(a);
		for (int j = 0; j < n1; j ++) {
			// 块内遍历（每块大小：p*q)
			tmp = {0,0,0};
			for (int i2 = 0;  i2 < p; i2 ++) {
				for (int j2 = 0; j2 < q; j2 ++) {
					int x = i * p + i2; // 平移
					int y = j * q + j2;
					// 计算块内总和
					tmp.r += img[x][y].r;
					tmp.g += img[x][y].g;
					tmp.b += img[x][y].b;
				}
			}
			tmp.r /= p*q; // 平均值
			tmp.g /= p*q;
			tmp.b /= p*q;
			imgavr[i].push_back(tmp);
		}
	}
    // 3.主控程序，遍历每小块并按要求输出
	pixel pre = {0,0,0}; // 前一次的背景色
	for (auto imgVec : imgavr) { // 每行
		for (auto block : imgVec) { // 每列
			if (block.r != pre.r || block.g != pre.g || block.b != pre.b) { // 与之前背景色不同
				if (block.r == 0 && block.g == 0 && block.b == 0) { // 是默认背景色
					output(defaultColor, pixel{0,0,0});
				}
				else output(backColor, block);
			}
			pre = block; // 更新背景色
			printf("\\x20"); // 空格
		}
		if (pre.r != 0 || pre.g != 0 || pre.b != 0) {
			pre = {0,0,0}; // 更新背景色
			output(defaultColor, pixel{0,0,0}); // 一行结尾非默认背景色
		}
		printf("\\x0A"); // 换行
	}
	return 0;
}
```


## [201903-3 损坏的RAID5](http://118.190.20.162/view.page?gpid=T87)

### 思路分析

​		这道题可直接模拟或者找规律，直接模拟思维量会小些，找规律需要多些耐心。但二者实现时均需使用fgets来读入硬盘内容，否则会超时。

​		本题有三个难点，读题，模拟/找规律，超时处理。

#### 读题

​		读题难点之一在于题目巨长，对新手很不友好，不过题目都是纸老虎，真正有用的就是标黄的部分。从标黄处获取到RAID**算法本质**就是在一个**二维数组（列为硬盘，行为块）**上做一些处理，只不过需遵守些规则罢了。因此，只需清楚校准位的选择和普通位置的选择规则即可。

​		难度之二在于理清`1条带=s块=4s字节=8s字符`的关系，同时，硬盘内容是以16进制字符来表示，即以字符为最小单位，因此，从硬盘内容的字符串长度来计算条带，块的个数时需注意换算关系。

​		难度之三在于理清**逻辑条带号**和**物理条带号**的区别，物理条带号是二维数组的行号，真是存在的；而逻辑条带号是贯穿整个二维数组，人为划分，做标识用，其实并不存在。了解过Cache工作机制的朋友应该会有较深理解。

#### 模拟/找规律

​		读完题后，若不想找规律就可以遍历二维数组，模拟选择规则，将每一个逻辑条带号对应的物理位置记录下来，查询时直接根据物理地找到相应的内容即可。

​		若想找规律，画一张图找到各自的关系。若给定硬盘数n，硬盘内容长度len，那么一个二维矩阵随之唯一确定，此时再给定每个条带包含的块数s（1块=4B=8字符是定死的），那么二维矩阵的行数为一个硬盘所包含的条带数stpNum=len/(8*s)，列数为硬盘数n。此时若给定要查询的虚拟块号bi，可进行如下推导：
$$
虚拟块号所属条带号stpId=虚拟块号bi/每个条带包含的块数s\\
虚拟条带号所属物理条带号（行号）k=stpId/(n-1)\\
校准位所属硬盘号d=(n-1)-(k\%n)\\
虚拟条带号所属硬盘号（物理列号）diskId=(d+(stpId\%(n-1))+1)\%n\\
虚拟块号对应物理地址起点beginIdx=(k*s+bi\%s)*8
$$


​		因此，只需知道查询的虚拟块号bi，就可根据以上公式得知它的物理地址，代码量极小。

#### 超时处理

​		若采用模拟方式编程，时间复杂度主要分为3个部分：输入，模拟分配算法，查询，三种均为10^7量级，但是模拟分配算法和查询部分均只涉及赋值，加减乘除等原子元素，速度快，但输入使用scanf，其需要调用系统函数，时间消耗极大。有与模拟分配算法没啥好优化的，就依次尝试以下方法优化查询：

1. 借鉴计算机缓存中的TLB快表思想，将访问过的块的内容直接存储到哈希表中，会`运行错误`，不是数组太小，而是接近512MB，导致爆栈了。

2. 在尝试1的基础上，改用map优化空间，依旧超时。尝试unordered_map，依旧失败，令map直接存储字符串下标，依旧超时，看来map是用不了了。
3. 再次坚定直接用哈希表的决心，把maxn改小，最多有10240000块，依旧爆栈，很纳闷，原来是string类型栈32字节，导致爆栈，因此用char二维数组存储，这下内存足够了，但是依旧超时。
4. 最后改变方向，优化输入，发现无论输入怎么优化也不行，最后借鉴了[常见输入效率比较](https://blog.csdn.net/richenyunqi/article/details/89203826)，发现**fgets**比scanf快13倍，改用它，就AC了。
5. 如果选择找规律，那么可以省略模拟分配算法的步骤。

### 测试样例

#### 样例1

```
// 输入
2 1 2
0 000102030405060710111213141516172021222324252627
1 000102030405060710111213141516172021222324252627
2
0
1
// 输出
00010203
04050607
```

#### 样例2

```
// input
3 2 2
0 000102030405060710111213141516172021222324252627
1 A0A1A2A3A4A5A6A7B0B1B2B3B4B5B6B7C0C1C2C3C4C5C6C7
2
2
5
// output
A0A1A2A3
A0A0A0A0
```

### AC代码

#### C++(模拟)

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-08-26 23:25:21
 * @LastEditTime: 2019-08-27 19:39:11
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
const int maxn = 10240010; // 最大块数
struct Pos {
    int dId; // 硬盘下标
    int sId; // 硬盘内的带号
}pos[maxn]; // 每条带对应的物理位置
char disk[1010][81200]; // 硬盘
char hashTable[maxn][9]; // 存在的直接输出
int len[1010] = {0}; // 记录硬盘长度
int n, s, l, m; // 硬盘数，条带大小，现存硬盘数，查询条数
int blkNum, stpNum; // 每个硬盘的块数，条数
char dth[20] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}; // 10 -> 16
map<char, int> htd; // 16进制-> 10进制
void init() {
    for(int i = 0; i < 16; i ++) htd[dth[i]] = i;
    blkNum = strlen(disk[0]) / 8; // 块数
    stpNum = blkNum / s; // 条带数
}
void solve() {
    init();
    // 模拟逻辑填入条带，记录每条带的物理位置
    int diskId = n - 1; // 硬盘号
    for(int k = 0; k < stpNum; k ++) { // 行，每个硬盘的条带数
        int d = diskId; // 选中校准硬盘
        diskId --; // 递减
        if(diskId == -1) diskId = n - 1;
        for(int j = 0; j < n - 1; j ++) { // 填入n-1条带
            d = (d + 1) % n;
            int b = (n - 1) * k + j; // 带号
            pos[b].dId = d; // 硬盘号/列号
            pos[b].sId = k; // 带号/行号
        }
    }
    // 查询
    int bi, did, beginIdx;
    for(int i = 0; i < m; i ++) {
        scanf("%d", &bi);
        if(bi >= blkNum * (n - 1)) {
            printf("-\n");
            continue;
        }
        did = pos[bi / s].dId; // 块->条带->硬盘
        // 不可得的数据
        if((n - l > 1 && len[did] == 0)) { // 缺失硬盘超过1块 || 块号超出总长
            printf("-\n");
            continue;
        }
        if(strlen(hashTable[bi]) != 0) { // 哈希表存储已经访问过的块，加快速度
            printf("%s\n", hashTable[bi]);
            continue;
        }
        // 可得到数据
        beginIdx = (pos[bi / s].sId * s + bi % s) * 8; // 字节开始位置
        if(len[did] != 0) { // 无缺失，直接输出
            for(int j = 0; j < 9; j ++) {
                hashTable[bi][j] = (j == 8) ? '\0' : disk[did][beginIdx + j];
            }
            printf("%s\n", hashTable[bi]);
        }
        else { // 缺失，需计算
            char res[9] = {'0', '0', '0', '0', '0', '0', '0', '\0'};//tmp[9];
            for(int d = 0; d < n; d ++) {
                if(len[d] != 0) {
                    for(int j = 0; j < 8; j ++) {
                        res[j] = dth[htd[res[j]] ^ htd[disk[d][beginIdx + j]]];
                    }
                }
            }
            for(int j = 0; j < 9; j ++) {
                hashTable[bi][j] = (j == 8) ? '\0' : res[j];
            }
            printf("%s\n", hashTable[bi]);
        }
    }
}
void readData() {
    scanf("%d %d %d", &n, &s, &l);
    int d;
    for(int i = 0; i < l; i ++) {
        scanf("%d ", &d);
        fgets(disk[d], 81200, stdin); // 会读入空格
        len[d] = 1; // 标记，表示非空
    }
    scanf("%d", &m);
}
int main() {
    readData();
    solve();
    return 0;
}
```

#### C++(找规律)

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-08-27 19:40:47
 * @LastEditTime: 2019-08-27 20:50:14
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
const int maxn = 82000; // 单个硬盘内容最大
char disk[1010][maxn]; // 硬盘内容存储
int n, s, l, m;
int len = 0, blkNum, stpNum; // 单个硬盘的总长、块数、条带数
int main() {
    scanf("%d %d %d", &n, &s, &l);
    int d;
    for(int i = 0; i < l; i ++) {
        scanf("%d ", &d);
        fgets(disk[d], maxn, stdin); // fgets才不会超时
        if(len == 0) len = strlen(disk[d]);
    }
    blkNum = len / 8;
    stpNum = blkNum / s;
    scanf("%d", &m);
    int bi, blkId, stpId, k, diskId;
    for(int i = 0; i < m; i ++) {
        scanf("%d", &bi);
        stpId = bi / s; // 所在的逻辑条带号
        k = stpId / (n - 1); // 在硬盘中的条带号（物理/行号）
        diskId = ((n - 1 - (k % n)) + (stpId % (n - 1)) + 1) % n; // 硬盘号=校准位置+相对位置+1
        // 超出总数 || 无法恢复
        if(bi >= blkNum * (n - 1) || (n - l > 1 && disk[diskId][0] == '\0')) {
            printf("-\n"); // 换行别漏
            continue;
        }
        int beginIdx = (k * s + bi % s) * 8; // 起始地址，1块=4B，1B需2个字符表示 
        if(disk[diskId][0] != '\0') { // 存在，直接输出
            for(int j = 0; j < 8; j ++) printf("%c", disk[diskId][beginIdx + j]);
        }
        else { // 丢失，异或同行的其他硬盘内容来恢复
            int ans = 0, tmp;
            char s[9];
            for(int d = 0; d < n; d ++) {
                if(disk[d][0] != '\0') {
                    for(int j = 0; j < 9; j ++) { // 提取同一行的块
                        s[j] = (j == 8) ? '\0' : disk[d][beginIdx + j];
                    }
                    sscanf(s, "%x", &tmp); // 转为10进制
                    ans ^= tmp;
                }
            }
            printf("%08X", ans); // 大写16进制输出，不足补0
        }
        printf("\n"); // 换行别漏
    }
    return 0;
}
```

### 小结

​		这是做得第一道模拟题，举步维艰，读懂题目花了快1小时，理清思路快1小时，代码调试小半天，不过在这不断尝试与反思的过程收获满满。

+ 调试技巧：在提交代码时可故意输出一个错误值，这样可以看到时间和空间使用情况，一般来说10^7的原子运算绝对不会超时，但是输入输出就不一定了，使用scanf/cin子类的都会超时。因此，处理大批量的字符串时，可考虑fgets，极快。
+ 时间优化：这次被超时逼得把所有能优化时间的技巧都试了一遍，如直接散列法爆栈，map/unordered_map实现散列法超时，利用散列实现打表依旧超时（访问过的记录下来，类似TLB快表思想），string占32字节，用它虽然方便，但时间和空间均需牺牲。strlen函数复杂度为O(n)，吓到我了。可以说是一次很好的融汇贯通的训练，这时间花得值。
+ 学习方式：参考的几篇博文不仅解题思路值得借鉴，其学习方式也值得学习，将五类读入字符串的函数进行比较的作者的学习态度与方式令人肃然起敬，以后也要这样，用行动说话，多时间，比较，思考，总结。或许我可以总结下各类输出函数的效率比较，通过类比应该是fputs效率最高。
+ 适应考试：现在的输入样例都是以图片形式给出，只能通过手打保存在文件中，粘贴到命令行中或者使用bat批文件处理，使用Windows的fc函数对比正确答案与输出的差异，适用于输出极多的时候。
+ 心理素质：这次练习，是心理素质稳步提高，耐力增强，不再恐惧又臭又长的题目，这都是用来伪装的外衣，其实它的本质内核都是很简单的东西，本题的本质就是一个二维数组，九层妖塔，起于累土，再难的东西，也可以通过分解与规约变成熟悉简单的玩意儿~

### 参考

+ [找规律](https://www.cnblogs.com/xidian-mao/p/10991393.html)

+ [模拟探究值得借鉴](https://blog.csdn.net/richenyunqi/article/details/89206423)

+ [各类读入函数的比较](https://blog.csdn.net/richenyunqi/article/details/89203826)



## [201812-3 CIDR合并](http://118.190.20.162/view.page?gpid=T82)

### 1 思路分析

​		本题有几个关键步骤：读题、字符串处理、求匹配集、模拟算法。即通过读题了解匹配集的计算，将字符串拆分为5个部分，分别用无符号整数存储，再用区间表示匹配集，最后利用双向链表模拟求解算法。

#### 1.1 读题

​		CSP第三题每次都是给出新的定义和算法过程，然我们去模拟还原。因此从题目获取关键信息尤为重要。本题关键在于理清：**IP=>IP加个长度表示IP前缀IP/len=>多个IP前缀组成IP前缀列表；IP前缀如何计算IP匹配集？**

​		前半部分根据题目所给信息，了解各自合法表示的规则以及相互关系即可。后半部分是重点，假设标准型IP前缀`123.2.0.0/16`，所有高16位为`123.2`的IP构成该前缀的匹配集`[123.2.0.0,123.2.255.255]`，即低16位可为任意数，不做限制。这就给我们一个解题的启发，匹配集用区间来表示，这个区间的左右边界可用IP匹配集的左右边界的十进制表示，便于比较。

#### 1.2 字符串处理

##### 1.2.1 数据结构

​		定义结构体类型PrefIP，以无符号整数存储IP的4个部分以及前缀长度。同时设置无符号整数val保存IP的10进制值，left，right分别表示该IP前缀的匹配集区间的左右边界，便于计算。代码如下：

```cpp
struct PrefIP {
    unsigned a[4]; // 依次表示a[0]~a[4]
    unsigned len; // 前缀长度
    unsigned left, right; // 匹配ip的左右区间[left,right]
    unsigned val; // IP的10进制值
    PrefIP() { // 默认构造初始化
        fill(a, a + 4, 0);
        len = left = right = 0;
        val = 0;
    }
};
```

##### 1.2.2 IP分割

​		读入字符串后，先根据`/`判断IP类型，若不存在，则为省略长度型；若存在，则为标准型或省略后缀型，因此可用find函数找到`/`位置，将IP和长度部分分离。接下来就是IP的分割，为了便于使用，封装如下IP分割函数：

```cpp
int splitIP(const string& s, PrefIP& prefIP) {
    stringstream input(s);
    string tmp;
    int j = 0; // IP分割
    while(getline(input, tmp, '.')) {
        sscanf(tmp.c_str(), "%u", &prefIP.a[j++]); // 转为无符号整数
    }
    return j; // IP有几个部分组成，省略长度型使用
}
```

#### 1.3 匹配集计算

​		提取出IP的每一部分和前缀长度后，该计算匹配集的左右区间了。由于向右移位的位数必须小于左边数值的最大位数（二进制），因此，当`len=32`时，`0xffffffff>>32`违反规则，会造成不确定行为，因此对len=32需进行特判处理。（若属性二进制运算的可以不用单独计算出左右区间这么麻烦，直接通过位运算计算完成模拟）。

```cpp
// 前缀IP的匹配集区间计算
void matchSet(PrefIP& p) {
    for(int i = 0; i < 4; i ++) { // IP转为10进制
        p.val = p.val * 256 + p.a[i];
    }
    p.left = p.val; // 左区间
    p.right = (p.len == 32) ? p.val : p.val + (0xffffffffu >> p.len); // 右区间 巨坑！！！
}
```

#### 1.4 模拟算法

​		由于题目已给出算法3个步骤：排序，合并具有包含关系的集合，合并同级集合。其中涉及的插入删除操作较多，随机查询较少，因此采用容器双向链表list来存储IP前缀列表。

##### 1.4.1 排序

​		list可用自带的sort函数，其中定义优先级可用lamda或者重载操作符<。

**（1）lamda函数**

```cpp
// 排序，IP值为第一标尺，前缀长度为第二标尺，均从小到大
_list.sort([](PrefIP& a, PrefIP& b) {return (a.val != b.val) ? a.val < b.val : a.len < b.len;});
```

**（2）重载操作符<**

​		在结构体**PrefIP**中以友元函数重载操作符<

```cpp
friend bool operator < (PrefIP& a, PrefIP& b) { // 友元
    return (a.val != b.val) ? a.val < b.val : a.len < b.len;
}
```

##### 1.4.2 合并具有包含关系的集合

​		从头到尾遍历依次遍历相邻的两个结点，若存在包含关系，删除被包含的结点。如何判断包含关系呢？之前已经将每个IP前缀的匹配集用区间表示出来，因此包含关系就是区间的包含关系。

```cpp
pa->left <= pb->left && pa->right >= pb->right; //满足该条件则pb包含于pa
```

##### 1.4.3 合并同级集合

**（1）合法判断**

​		算法逻辑较简单，主要是新a'的合法性判断，合法的IP前缀`IP/len`同时满足以下3个标准：

1. IP表示合法

2. len位于[0,32]

3. IP的低32-len位均为0

	具体分析如下：

1. 由于题目保证输入的IP前缀均合法，因此a的IP必定合法，满足标准1；

2. a的len必定也合法，若len不为0，那么len-1必定合法，若len=0，那么一定是`0.0.0.0/0`，其匹配集为全体IP，因此在第一次合并具有包含关系时就将其他的所有IP合并了，到这一步合并就只剩它一个IP。综上，len-1必定合法，满足标准2

3. a的低32-len为必定合法，那么只要a的第32-len位为0，那么必定合法，满足标准3；为1则不合法。

​		综上所述，只需判断a的第32-len位是0或是1即可判断合法与否。（**&的优先级低于==，需加括号**）

```cpp
((pa->val >> (32 - pa->len)) & 1u) == 0 ; //结果为真则合法
```

**（2）并集求解**

​		对a'重新计算匹配集后，a，b匹配集的并集就是区间的并集，left取最小，right取最大即可。



### 2 注意点

- 使用全局变量prefIP，每次使用前必须更新，否则会被之前的影响，编程失误，最好不要用全局变量。（40->90分）
- 最后一个测试样例包含`255.255.255.255`，在计算匹配集时`0xffffffff>>32`会溢出为-1，导致区间错误。实际上并不是溢出，而是右移的位数必须小于左边数值的最大位数，否则行为无定义。可能会变成任意数。
- `& ^ |`的优先级低于关系运算符`== > < >= <= !=`



### 3 测试样例编写

#### **3.1 边界测试**

**n=1，len=0,7,32，三个输入格式**

```
//input：标准型:len=7
1
1.2.3.128/7
//output
1.2.3.128/7

//input：省略后缀型：len=0
1
0/0
//output
0.0.0.0/0

//input：省略长度型：len=32
1
1.2.3.4
//output
1.2.3.4
```

#### 3.2 排序+合并+去重测试

```
//input：三种类型均有->排序+合并测试
4
1.2.2
1.2.1/25
1.2.1.8/25
1.2.1.0/24
//output
1.2.1.0/24
1.2.2.0/24

//input：排序+合并+去重测试
6
1.2.2
1.2.1/25
1.2.1.8/25
1.2.1.0/24
1.2.1/25
1.2.1.8/25
//output
1.2.1.0/24
1.2.2.0/24

//input：排序+合并+去重测试
4
1.3/16
1.2
1.4
1.2.128/17
//output
1.2.0.0/15
1.4.0.0/16

//input
3
0/0
1.1
1.2
//output
0.0.0.0/0
```



### 4 C++（字符串处理+链表+集合+位运算）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-08-28 09:17:24
 * @LastEditTime: 2019-08-28 23:11:20
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
struct PrefIP {
    unsigned a[4]; // 依次表示a[0]~a[4]
    unsigned len; // 前缀长度
    unsigned left, right; // 匹配ip的左右区间[left,right]
    unsigned val; // IP的低32-len均为0的10进制值
    PrefIP() {
        fill(a, a + 4, 0);
        len = left = right = 0;
        val = 0;
    }
    // friend bool operator < (PrefIP& a, PrefIP& b) { //和优先队列使用方式一样
    //     return (a.val != b.val) ? a.val < b.val : a.len < b.len;
    // }
};
list<PrefIP> _list; // 双向链表表示前缀列表
// 分割IP
int splitIP(const string& s, PrefIP& prefIP) {
    stringstream input(s);
    string tmp;
    int j = 0; // IP分割
    while(getline(input, tmp, '.')) {
        sscanf(tmp.c_str(), "%u", &prefIP.a[j++]); // 转为无符号整数
    }
    return j;
}
void printIP(PrefIP& p) {
    for(int i = 0; i < 4; i ++) {
        printf("%d%s", p.a[i], i == 3 ? "/" : ".");
    }
    printf("%d\n", p.len);
    // printf("%08x %08x %08x\n", p.val, p.left, p.right);
}
// 前缀IP的匹配集区间计算
void matchSet(PrefIP& p) {
    for(int i = 0; i < 4; i ++) { // IP转为10进制
        p.val = p.val * 256 + p.a[i];
    }
    p.left = p.val; // 左区间
    p.right = (p.len == 32) ? p.val : p.val + (0xffffffffu >> p.len); // 右区间 巨坑！！！
}
// 算法模拟
void solve() {
    // 排序，IP值为第一标尺，前缀长度为第二标尺，均从小到大
    _list.sort([](PrefIP& a, PrefIP& b) {return (a.val != b.val) ? a.val < b.val : a.len < b.len;});
    // 从小到大合并
    auto pa = _list.begin(), pb = pa;
    pb ++; // 只能用自增符号
    while(pb != _list.end()) { // 从头开始遍历
        if(pa->left <= pb->left && pa->right >= pb->right) { // b的匹配集包含于a的匹配集
            pb = _list.erase(pb); // 删除pb结点，返回其下一个结点
        }
        else { // 向后移动
            pa = pb;
            pb ++;
        }
    }
    // 同级合并
    pa = pb = _list.begin();
    pb ++;
    while(pb != _list.end()) {
        if(pa->len == pb->len) { // 前缀长度相等
            // a的匹配集合法，低32-len均为0，pa的第32-len位为0即可，&的优先级低于判断==
            if(((pa->val >> (32 - pa->len)) & 1u) == 0) { 
                PrefIP a = *pa; // a的IP与pa相同
                a.len = pa->len - 1; // 前缀长度小1
                matchSet(a); // 重新计算区间
                if(a.left == min(pa->left, pb->left) && a.right == max(pa->right, pb->right)) { // a匹配集等于pa并pb
                    _list.erase(pa); // 删除pa，pb
                    auto it = _list.erase(pb); 
                    pa = pb = _list.insert(it, a); // 在pb后一个结点前插入a
                    if(pa != _list.begin()) -- pa; // a的前面有元素，从前一个开始
                    else ++ pb; // 前面无结点，从当前开始
                    continue;
                }
            }
        }
        // 不同时满足以上3个条件，向后走
        pa = pb;
        ++ pb;
    }
}
int main() {
    int n;
    scanf("%d", &n); 
    getchar(); // 吸收多余换行
    char str[25];
    string s;
    for(int i = 0; i < n; i ++) {
        fgets(str, 25, stdin); // 速度快
        s = str;
        PrefIP prefIP; // 不要定义为全局变量，导致交叉感染
        auto p = s.find('/'); // 找 / 的位置
        if(p == string::npos) { // 不存在/，省略长度型
            prefIP.len = 8 * splitIP(s, prefIP); // 分割IP并计算长度：8的整倍数
        }
        else { // 标准型或省略后缀型
            sscanf(s.c_str() + p + 1, "%u", &prefIP.len); // 长度
            splitIP(s.substr(0, p), prefIP); // 分割IP
        }
        matchSet(prefIP); // 计算匹配集
        _list.push_back(prefIP);
    }
    solve(); // 模拟算法
    // 输出
    for(auto p : _list) {
        printIP(p);
    }
    return 0;
}
```



## [201809-3 元素选择器](http://118.190.20.162/view.page?gpid=T77)

### 1 思路分析

​		第三题老套路，总是离不开字符串处理，不过好像涉及高级数据结构的题目数据量都较小，所以本题无需考虑时空复杂度，直接可用string容器，其中包含许多便利的字符串处理函数。

​		 算法主要分为有三个难点：**字符串处理，建立树，查询方式**。根据建立树的方式不同，可分为两种思路：

1. 一是借鉴**并查集**思想，记录每个结点的父结点来构建一棵树（并非真正意义的树）。查询时先在树中找到满足最后一个查询条件的所有结点，对每一个结点进行父结点回溯，依次判断是否满足剩余的查询条件。这个实现比较简单，但不容易想到，[具体可参考这里](https://blog.csdn.net/richenyunqi/article/details/85251149)。

2. 二是朴素的思想，建立一棵**普通静态树**，即记录每个结点的孩子结点，恰恰与方法1相反，因此查询方式也与方法1相反，这里是从上到下。可将查询分为两种情况：

	**（1）单级查询：**直接遍历（前中后层序皆可），找出所有满足的结点。

	**（2）多级查询：**假设一行查询有n个查询条件，先dfs找到满足前n-1个条件的第一个结点root，再对以该结点为根的子树进行**单级查询**最后一个条件。

​		这里详细解释第二种思路，因此先建立结构体类型STNode表示静态树的结点。其中依次包括表示元素，id，层号，孩子结点列表的字段。

```cpp
const int maxn = 105;
struct STNode {
    string element, id; // 元素，id
    int layer; // 层号
    vector<int> child; // 子结点列表
}stree[maxn];
```

​		再建立结构体类型Query来表示查询的一个结点，包含查询内容和类型。

```cpp
struct Query { // 查询
    string content; // 查询内容
    int type; // 类型：元素：0；id：1
}tqy;
vector<Query> query; // 存储一条的查询路径
```

#### 1.1 字符串处理

##### 1.1.1 结构化文档

​		使用string自带的函数，来提取每行字符串中的3类信息：行号、层号、标签、id。

1. **行号**：定义int型i，初值为1，每处理完一行就加1，i作为该结点在数组的下标，也代表行号。
2. **层号**：通过string的find_first_not_of函数找到第一个不是`.`的元素下标，即为`.`的个数，除以2，就是层号。

``` c++
stree[root].layer = s.find_first_not_of('.') / 2; // 层号：.的个数除以2
```

3. **标签和id**：主要是substr和find函数使用**（ps:取子串时需去除换行）**。先根据find函数找到`#`位置，再用substr取出标签和id即可。其中标签不区分大小写，因此统一转为小写，在查询时也如此处理。可用transform函数，完成转换，具体如下：

```cpp
transform(e.begin(), e.end(), e.begin(), ::tolower); // 元素全转为小写，大小写不敏感
```

##### 1.1.2 查询选择器

​		而查询的字符串分割比上面的步骤少了对`.`的处理，因此完全可以套用上面处理方式。但这里需要不仅要获取内容，还要获取类型。这里可将一条查询的每个部分看成一个结点，每个查询结点都以空格间隔，因此可用更简单的stringstream处理分割内容，得到内容后，根据s[0]是否为#判断其类型（结构化文档将**标签类型转为小写**，这里保持统一，也转为小写）。

```cpp
void getQuery() {
    char str[90];
    fgets(str, 90, stdin);
    string s = str, tmp;
    stringstream input(s.substr(0, s.size() - 1)); // 去换行
    while(getline(input, tmp, ' ')) { // 空行分割
        if(tmp[0] == '#') { // id
            tqy.content = tmp.substr(1);
            tqy.type = 1;
        }
        else { // 标签
            transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower); // 转为小写
            tqy.content = tmp;
            tqy.type = 0;
        }
        query.push_back(tqy);
    }
}
```

#### 1.2 建立普通树

​		普通树的建立关键是记录每个结点的孩子结点。使用静态数组建立普通树，数据结构在前文已给出，注意到结点是按前序遍历给出的顺序，因此可用**前序建树**的思想，递归实现有些麻烦，因此选择用**栈模拟实现**。

​		根结点先入栈，遍历每一个结点，若当前层号小于等于栈顶层号，弹出栈顶；否则将当前结点添加为栈顶的孩子，并入栈。具体如下：

```cpp
// 栈模拟前序建树
void createStree(int root) {
    stack<int> stk;
    stk.push(root); // 根结点入栈
    int i = root + 1; 
    while(i <= N) { 
        while(stree[i].layer <= stree[stk.top()].layer) stk.pop(); // 保证top是i的父结点
        stree[stk.top()].child.push_back(i); // 将i添加为top的孩子结点
        stk.push(i); // i入栈，作为当前的父结点
        i ++;
    }
}
```

#### 1.3 查询方式

​		查询分为两种情况：单级查询和多级查询（**前序遍历不包含root结点**）。

1. 单级查询：直接前序遍历整棵树，记录匹配的结点。
2. 多级查询：先用dfs找到满足前n-1个查询条件的第一个结点root，再对root进行单级查询。

```cpp
// 遍历满足前query.size()-1个的结点root，查询root的子树中满足最后一个条件的结点
// root：当前结点；num：已满足的查询条件个数
void dfs(int root, int num) {
    if(query.size() == 1) { // 单级查询特判
        if(isEqual(root, num)) ans.push_back(root); // 因前序遍历不包含root，所以需特判
        preOrder(root, num); // 前序遍历，不包含root
        return;
    }
    if(isEqual(root, num)) { // 多级查询
        num ++;
        if(num == query.size() - 1) {
            preOrder(root, num); // 获取所有符合条件的结点，不包含root
            return;
        }
    }
    for(auto p : stree[root].child) { // 遍历所有子结点
        dfs(p, num);
    }
}
```

### 2 注意点

+ 熟练使用string自带的字符串处理函数s.find，s.find_first_not_of；系统自带的find，find_if_not条件查询。fgets或getline会读入换行符，使用substr取子串时需要**去除换行符**。
+ **标签**在结构化文档和查询处理时全部**统一为小写或大写**。
+ 查询列表query和答案列表ans每次使用前记得清空。
+ 本题按照行号从小到大建立树，遍历也是按这个顺序，因此输出就是升序（若不是，可用set优化）。
+ 递归前序建树难于栈模拟前序建树！！！
+ 总体来说，并查集思路优于直接建树，毕竟迭代比递归好写好调试。

### 3 测试样例

​		涉及高级数据结构测试就变得容易了，只要边界测试正确，再来一个一般测试正确，那么基本上就是对的，因为像树是递归化定义，所以递归化测试就很遍历，不用想那么多特例。以下是题目样例：

```
//input
11 5
html
..head
....title
..body
....h1
....p #subtitle
....div #main
......h2
......p #one
......div
........p #two
p
#subtitle
h3
div p
div div p
//output
3 6 9 11
1 6
0
2 9 11
1 11
```

### 4 C++（树/并查集+字符串处理+树遍历）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-08-29 09:49:20
 * @LastEditTime: 2019-08-29 20:56:24
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
const int maxn = 105;
struct STNode {
    string element, id; // 元素，id
    int layer; // 层号
    vector<int> child; // 子结点列表
}stree[maxn];
struct Query { // 查询
    string content; // 查询内容
    int type; // 类型：元素：0；id：1
}tqy;
vector<Query> query; // 存储一条的查询路径
vector<int> ans; // 存放答案
int N, M; // 结点总个数；查询条数
// 读取每一行，处理字符串，存入结点
void getNode(int root) {
    char str[90];
    fgets(str, 90, stdin);
    string s = str;
    stree[root].layer = s.find_first_not_of('.') / 2; // 层号：.的个数除以2
    s = s.substr(stree[root].layer * 2, s.size() - stree[root].layer * 2 - 1); // 去除.. 和尾部换行
    auto p = s.find('#'); 
    auto& e = stree[root].element; // 便于使用
    if(p != string::npos) { // 存在id
        e = s.substr(0, p - 1); // 排除空格
        stree[root].id = s.substr(p + 1, s.size() - p - 1); // 排除# 
    }
    else e = s; // 只有元素
    transform(e.begin(), e.end(), e.begin(), ::tolower); // 元素全转为小写，大小写不敏感
}
// 栈模拟前序建树
void createStree(int root) {
    stack<int> stk;
    stk.push(root); // 根结点入栈
    int i = root + 1; 
    while(i <= N) { 
        while(stree[i].layer <= stree[stk.top()].layer) stk.pop(); // 保证top是i的父结点
        stree[stk.top()].child.push_back(i); // 将i添加为top的孩子结点
        stk.push(i); // i入栈，作为当前的父结点
        i ++;
    }
}
// 分割查询的路径
void getQuery() {
    char str[90];
    fgets(str, 90, stdin);
    string s = str, tmp;
    stringstream input(s.substr(0, s.size() - 1)); // 去换行
    while(getline(input, tmp, ' ')) { // 空行分割
        if(tmp[0] == '#') { // id
            tqy.content = tmp.substr(1);
            tqy.type = 1;
        }
        else { // 元素
            transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower); // 转为小写
            tqy.content = tmp;
            tqy.type = 0;
        }
        query.push_back(tqy);
    }
}
// 判断root结点与查询条件query[num]是否相等
bool isEqual(int root, int num) {
    auto& q = query[num];
    auto& t = stree[root];
    return q.type == 0 && q.content == t.element || q.type == 1 && q.content == t.id;
}
// 前序遍历以root为根，所有子结点中等于query[num]的结点（排除root)
void preOrder(int root, int num) {
    if(root <= N) {
        for(auto p : stree[root].child) {
            if(isEqual(p, num)) ans.push_back(p); // 符合则记录
            preOrder(p, num);
        }        
    }
}
// 遍历满足前query.size()-1个的结点root，查询root的子树中满足最后一个条件的结点
void dfs(int root, int num) {
    if(query.size() == 1) { // 单个查询特判
        if(isEqual(root, num)) ans.push_back(root);
        preOrder(root, num);
        return;
    }
    if(isEqual(root, num)) { // 多级查询
        num ++;
        if(num == query.size() - 1) {
            preOrder(root, num); // 获取所有符合条件的结点
            return;
        }
    }
    for(auto p : stree[root].child) { // 遍历所有子结点
        dfs(p, num);
    }
}
int main() {
    scanf("%d %d", &N, &M);
    getchar();
    for(int i = 1; i <= N; i ++) getNode(i);
    createStree(1); // 建树
    for(int i = 0; i < M; i ++) {
        query.clear(); // 记得清空
        getQuery(); // 获取查询路径
        ans.clear(); // 结果清空
        dfs(1, 0); // 搜索答案
        // 输出
        if(ans.empty()) printf("0\n");
        else {
            printf("%d ", ans.size());
            for(int i = 0; i < ans.size(); i ++) {
                printf("%d%s", ans[i], i == ans.size() - 1 ? "\n" : " ");
            }
        }
    }
    return 0;
}
```

### 5 总结

​		做这题可谓一波三折，哪三折呢？依次为字符串处理，建树方式，查询方式。每一个都卡了好久，这美好的一天就悄然而逝。为啥卡呢？

1. 字符串处理：不熟悉string和常见的字符串处理函数，每一步都需要打印验证是否正确，不过确实学到了许多东西，如stringstream做分割使用，find，find_first_not_of，和条件查询find_not_of（lamda表示断言）。
2. 建树方式：一开始死磕递归前序建树，搞半天出不来，下午灵光一现，使用栈模拟实现，三下五除二就搞定了，可见方向的重要性。
3. 查询方式：一开始也是死磕dfs先找到满足前n-1个查询条件的结点root，在前序遍历root，找最后一个结点。思路确实没错，但是混乱不堪，导致递归函数写得有问题。我愣是没注意到分单级查询和多级查询两种情况讨论，还是一步步调试得到的这个结论，想哭。由于昨晚一宿与可爱的蚊子同眠，加上闷热空气的怀抱，我成功的失眠并且得到一个落枕奖励。再下午4点精神快奔溃时，拖着疲惫的身躯上了床，打开了小视频，然后安然入睡，快8点醒来神清气爽，到后街买了个烤鸡腿，太好吃了，嘿嘿嘿，然后回来就想出来了。果然，还是得劳逸结合才行。

​		现在深刻体会到纸上得来终觉浅，绝知此事要躬行，看起来再简单的事，多问几个为什么，也就不简单了，做题就是分解分解再分解，规约规约再规约，直到我熟悉的子问题，这不就是分治嘛。



## [201803-3 URL映射](http://118.190.20.162/view.page?gpid=T71)

### 1 思路分析

​		可直接模拟或是用正则表达式处理，这里选择比较简单的方式，正则表达式处理。

+ <int>：`"([\\d]+)"`，0~9的数字
+ <str>：`"([^/]+)"`，不存在`/`的字符串
+ <path>：`"(.+)"`，任意字符串

​		从中也容易看出三者具有大小关系：<int><<str><<path>，若是直接模拟的话，可从这里入手。还需注意<int>类型去除前导0问题，因此可用二维数组type记录每条规则的参数类型，匹配成功时，输出相应要求格式的字符串。

### 2 注意点

+ <path>最后是否有/，需特别记录
+ 规则和查询的url末尾的`/`同时有无才可匹配成功，4个测试点。
+ <int>去前导0,0000是特例，需要保留1位。cin>>优先级高于？：
+ 正则表达式结果通过res.str()转为string，第0个是完全匹配，1~N是分组匹配，因此需特判是否有参数。

### 3 测试样例

- 无参数，匹配成功+不成功
- 有参数
	- URL+单纯<int>
	- URL+单纯<str>
	- URL+单纯<path>（输入查询需检测是否以/结尾）
	- URL+<int>+<str>
	- URL+<int>/<str>+<path>
	- URL+<int>+<str>+<path>
	- URL+<int>+URL+<str>+URL+<path>
- 查询比URL长或短

```
// input
6 100
/c/01/str/ c1
/a/<int>/<path> a1
/a/<int>/<str>/<path> a2
/a/<str>/a/<int>/m/<path> a3
/a/<str>/<path> a4
/b/a/<int>/<path> b1
/c/01/str/
/c/01
/c1/01/str/0
/a/str/a/09123/m/i-j.js/t/
//output
c1
404
404
a3 str 9123 i-j.js/t/
```

### 4 C++（正则表达式）

​		自己最开始写的代码是直接模拟，但死活只有90分，到现在还没找到问题，所以先把这个AC代码贴上来。

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-08-30 22:46:59
 * @LastEditTime: 2019-09-03 15:44:09
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
vector<pair<string, regex> > rules; // 规则名字name->正则表达式
vector<vector<int> > types; // 每条规则对应的参数类型；<int>:1 ; 其它为0
vector<pair<regex, string> > trans = {{regex("<int>"), "([\\d]+)"}, {regex("<str>"), "([^/]+)"}, {regex("<path>"), "(.+)"}};
int n, m;
void getRules() {
    scanf("%d %d", &n, &m);
    string name, s;
    for(int i = 0; i < n; i ++) {
        cin >>s >>name;
        // 保存每个分割点类型
        stringstream input(s.substr(1));
        vector<int> type;
        string tmp;
        while(getline(input, tmp, '/')) {
            if(tmp == "<int>") type.push_back(1);
            else if(tmp == "<str>" || tmp == "<path>") type.push_back(0);
        }
        types.push_back(type);
        // 参数替换为相应的正则表达式字符串
        for(auto p : trans) {
            s = regex_replace(s, p.first, p.second); // 返回被替换的结果 
        }
        rules.push_back({name, regex(s)}); // 构造新的正则表达式
    }
}
void query(string s) {
    smatch res;
    for(int i = 0; i < rules.size(); i ++) {
        if(regex_match(s, res, rules[i].second)) {
            cout <<rules[i].first; // name
            for(int j = 1; j <= res.size(); j ++) {
                if(res.size() == 1) break; // 无参数
                cout <<" ";
                string tmp = res.str(j);
                if(types[i][j-1] == 1) { // 去除前导0
                    int idx = tmp.find_first_not_of('0');
                    printf("%s", (idx == string::npos) ? "0" : tmp.substr(idx).c_str()); // 考虑全零特例：000000
                }
                else cout <<tmp; // 直接输出，path是根据输入原样输出，因此无需考虑最后的/
            }
            cout <<endl;
            return; // 直接返回
        }
    }
    cout <<"404" <<endl;
}
int main() {
    getRules();
    for(int i = 0; i < m; i ++) {
        string s;
        cin >>s;
        query(s);
    }
    return 0;
}
```

### 5 参考

+ [直接处理40行代码](https://blog.csdn.net/best335/article/details/99698270)

+ [暴力87行代码](https://blog.csdn.net/tigerisland45/article/details/81697594)
+ [正则表达式43行代码](https://blog.csdn.net/richenyunqi/article/details/85260248)

## [201712-3 Crontab](http://118.190.20.162/view.page?gpid=T66)

### 1 思路分析

​		本题逻辑很复杂，涉及到日期处理，直接暴力枚举每个时刻容易超时，因此采用构造法，从命令出发，找到所有符合命令的时间，然后去判断该时间是否存在，从而降低时间复杂度。主要有以下几个重要问题：

+ 如何构造所有符合命令的时间？暴力枚举所有时间易超时，使用构造法，找到每个命令五个部分各自的所有可能取值（**不是取值范围，是具体可以取哪个值**），然后枚举构造出每个日期，将符合要求的记录下来。
+ 如何判断该时间是否存在？主要是当前日期yyyymmdd是星期几的计算。

#### 1.1 数据结构

+ set<*int*> cmdTime[5]存储命令5项的所有可能取值：minute,hour,monthDay,month,weekDay。set有去重功能，以此来解决前文第一个问题。

+ 用long long存储起止日期，通过**除法和求余**可得任意部分，拼接构造时间时也无需考虑时分的补0问题。
+ vector<string> command记录命令的名称，避免反复读取字符串，导致超时。

+ 使用map<long long,vector<int>>记录日期对应的命令下标，map按key自动升序，若相等，按照读入命令顺序排列。因此，最后直接输出即可。记录下标是为了不超时。
+ 星期和月份可能出现字母，统一转换为小写。

#### 1.2 当前日期是星期几？

​		根据1970.1.1是周4，按年月日分别计算天数，对7取余即可。模板化代码具体如下：

```cpp
int getWeekday(int year, int month, int day) { // 1970.1.1为周4 => 获取当前日期是星期几
    int ret = 4;
    for(int y = 1970; y < year; y ++) { // 年
        int sum = (isLeap(y)) ? 366 : 365; // 闰平年
        ret = (ret + sum) % 7;
    }
    for(int m = 1; m < month; m ++) { // 月
        int sum = maxMonthDay(year, m); // 当前月份天数
        ret = (ret + sum) % 7;
    }
    ret = (ret + day - 1) % 7; // 日
    return ret;
}
```

### 2 注意点

+ longlong输出格式：`lld`，`ld`是`long int`！！！

### 3 测试样例

```
// input
3 201711170032 201711222352
0 7 * * 1,3-5 get_up
30 23 * * Sat,Sun go_to_bed
15 12,18 * * * have_dinner
// output
201711170700 get_up
201711171215 have_dinner
201711171815 have_dinner
201711181215 have_dinner
201711181815 have_dinner
201711182330 go_to_bed
201711191215 have_dinner
201711191815 have_dinner
201711192330 go_to_bed
201711200700 get_up
201711201215 have_dinner
201711201815 have_dinner
201711211215 have_dinner
201711211815 have_dinner
201711220700 get_up
201711221215 have_dinner
201711221815 have_dinner
```

### 4 C++（字符串+日期+构造法）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-08-31 12:13:20
 * @LastEditTime: 2019-09-03 15:30:43
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
LL s, t; // 起止时间
vector<string> command; // 命令名称，避免超时
map<LL, vector<int> > ans; // 每个时间对应的命令名字下标，避免超时
set<int> cmdTime[5]; // 命令5项的所有可能取值：minute,hour,monthDay,month,weekDay
map<string, int> monthAndWeekday = { // 月份和星期的映射，约定用小写
    {"jan", 1}, {"feb", 2}, {"mar", 3}, {"apr", 4}, {"may", 5}, {"jun", 6}, 
    {"jul", 7}, {"aug", 8}, {"sep", 9}, {"oct", 10}, {"nov", 11}, {"dec", 12}, 
    {"sun", 0}, {"mon", 1}, {"tue", 2}, {"wed", 3}, {"thu", 4}, {"fri", 5}, {"sat", 6}
};
vector<pair<int, int> > timeRange = {{0, 59}, {0, 23}, {1, 31}, {1, 12}, {0, 6}}; // 对应五个部分的所有取值范围
const LL year = 1e8, month = 1e6, day = 1e4, hour = 1e2;
int monthDay[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 平年月份天数
// 将字符串转为数值
int getNumber(string s) {
    int ret;
    if(isdigit(s[0])) { // 数值型
        sscanf(s.c_str(), "%d", &ret);
    }
    else { // 字符型
        for(auto& c : s) c = tolower(c); // 统一转为小写
        ret = monthAndWeekday[s];
    }
    return ret;
}
// 获取一条命令的五个时间取值及名字
void getCmdTime() {
    string s, tmp, name;
    for(int i = 0; i < 5; i ++) {
        cmdTime[i].clear(); // 清空
        cin >>s;
        if(s[0] == '*') { // 任意值
            for(int j = timeRange[i].first; j <= timeRange[i].second; j ++) cmdTime[i].insert(j);
            continue; // 直接进入下一部分
        }
        // 具体范围
        stringstream input(s);
        while(getline(input, tmp, ',')) { // 以,分割字符串
            int pos = tmp.find('-'), l, r; // 以-分割左右区间
            if(pos == string::npos) { // 左右相同
                l = getNumber(tmp);
                r = l;
            }
            else { // 左右区间不同
                l = getNumber(tmp.substr(0, pos));
                r = getNumber(tmp.substr(pos + 1, tmp.size() - pos - 1));
            }
            for(int j = l; j <= r; j ++) { // 保存所有取值
                cmdTime[i].insert(j); // set去重
            }
        }
    }
    cin >>name;
    command.push_back(name); // 保存命令名称
}
bool isLeap(int year) { // 判断闰年
    return (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);
}
int maxMonthDay(int year, int month) { // 返回当前月份的最大天数
    if(isLeap(year) && month == 2) return monthDay[month] + 1;
    else return monthDay[month];
}
int getWeekday(int year, int month, int day) { // 1970.1.1为周4 => 获取当前日期是星期几
    int ret = 4;
    for(int y = 1970; y < year; y ++) { // 年
        int sum = (isLeap(y)) ? 366 : 365; // 闰平年
        ret = (ret + sum) % 7;
    }
    for(int m = 1; m < month; m ++) { // 月
        int sum = maxMonthDay(year, m); // 当前月份天数
        ret = (ret + sum) % 7;
    }
    ret = (ret + day - 1) % 7; // 日
    return ret;
}
void calCmd(int c) { // 计算编号为c的命令对应的合法时间
    for(int y = s / year; y <= t / year; y ++) { // 年
        for(auto m : cmdTime[3]) { // 月
            for(auto d : cmdTime[2]) { // 日
                if(d > maxMonthDay(y, m)) continue; // 当前年月没有这一天
                if(cmdTime[4].count(getWeekday(y, m, d)) != 0) { // 星期匹配
                    for(auto h : cmdTime[1]) { // 时
                        for(auto minute : cmdTime[0]) { // 分
                            LL time = y * year + m * month + d * day + h * hour + minute; // 计算当前时间
                            if(time >= s && time < t) ans[time].push_back(c); // 范围之内保存结果
                        }                        
                    }
                }
            }
        }
    }
}
void showResult() { // 输出结果
    for(auto t : ans) {
        for(auto c : t.second) {
            printf("%lld %s\n", t.first, command[c].c_str());
        }
    }
}
int main() {
    int n;
    cin >>n >>s >>t;
    for(int i = 0; i < n; i ++) {
        getCmdTime();
        calCmd(i);
    }
    showResult();
    return 0;
}
```

### 5 参考

+ [思路巧妙](https://blog.csdn.net/richenyunqi/article/details/86720394)

### 6 总结

​		这是碰到的第一个日期处理，从最开始接触编程就对日期处理不明不白，甚至有些恐惧，因为平闰年处理，月份处理，天数处理，星期推算，这次正好，一网打尽，全部弄懂。它虽然看起来复杂，但设计良好的数据结构可以极大简化逻辑复杂度，参考中的思路真是受益匪浅。再有就是对构造法来构造所有可能解，通过验证方式保留最终解。如何构造？不是记录每个解取值范围，而是记录其具体的值，这是思维上的一个突破，当初想用构造法时就是卡在这里，若用取值范围就太复杂了。

## [201709-3 JSON查询](http://118.190.20.162/view.page?gpid=T61)

### 1 思路分析

​		本题就是[201809-3 元素选择器](http://118.190.20.162/view.page?gpid=T77)的进阶版本，同样可用建树，查询的处理思路，此处仅仅是建树有些差别而已。**元素选择器**由于每一行都清晰给出了高度，且每一行仅有一个顶点，较容易分割顶点。因此，如何建树成为关键。

#### 1.1 建树

##### 1.1.1 去空格

​		去除所有多余的空格，拼接所有字符串保存于json中。

##### 1.1.2 遍历建树

​		步骤 1：将0号元素作为根，先入栈，因此从第1个字符开始读取，每次读取一对key，value。

​		步骤 2：遇到`:`之前的字符均拼接为key，之后根据`:`之后的符号是`{ 还是 "`来判断value是对象Object还是字符串String。若是object，将当前key入栈，value置为OBJECT，同时把当前结点记录为栈顶的孩子；否则将`"`之前的字符拼接为value，将其记录为栈顶的孩子，之后遇到逗号直接跳过，遇到`}`弹出栈顶，直到遇见第一个不是逗号和右花括号的字符。

​		步骤 3：继续步骤2直至json遍历完成。

### 2 注意点

+ vector类型没初始化不允许使用下标访问，如定义vector<int>a；里面没元素是不许用a[i]方式访问。
+ 认真仔细的处理字符串，基本没问题。

### 3 测试样例

```json
7 7
{
"k1" : "v1",
"k2":"v2",
"k3": {"k31": "v31", "k32":"v32", "k33":{"k331":"v331", "k332":"v332", "k333":{"k3331":"v3331"}}},
"k4":{"k41":"v41"},
"k5":"v5"
}
k1
k2.v3
k3.k33.k33
k3.k33.k333
k3.k33.k333.k3331
k4.k41
k5
// output
STRING v1
NOTEXIST
NOTEXIST
OBJECT
STRING v3331
STRING v41
STRING v5
```

### 4 C++（栈模拟建树+查询+字符串处理）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-01 09:44:12
 * @LastEditTime: 2019-09-03 07:20:04
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
struct Node { // 静态树结点
    string key, value; // 键，值
    vector<int> child; // 孩子序列
};
vector<Node> tree(10000); // 静态树
int n, m, tNum = 1; // 行数、查询行数、树结点编号，从1开始，0默认为根
string json; // 存储去除空格和换行后的json字符串
void readData() { // 读入数据，去除空格，拼接保存为json
    scanf("%d %d", &n, &m);
    getchar(); // 吸收多余换行
    string s;
    for(int i = 0; i < n; i ++) {
        getline(cin, s);
        for(auto c : s) if(c != ' ') json += c; // 去空格
    }
}
void createTree() { // 分割key，value，栈模拟建立树
    stack<int> stk;
    stk.push(0); // 0作为root
    int i = 1; // json下标，去头{
    do {
        string key, value;
        while(json[i] != ':') { // 获取key
            if(json[i] == '\\') { // 转义符无条件保留它后面一位
                key += json[i + 1];
                i ++;
            }
            else if(json[i] != '"') key += json[i]; // 其余不是引号都保存
            i ++;
        }
        if(json[i] == ':') { // 获取value
            ++ i;
            if(json[i] == '{') { // value为对象OBJECT
                tree[tNum].key = key;
                tree[tNum].value = "OBJECT";
                tree[stk.top()].child.push_back(tNum); 
                stk.push(tNum); // 遇{入栈
                ++ tNum;
                ++ i;
            }
            else { // value为对象STRING
                while(json[i] != ',' && json[i] != '}') { // 提取value，和提取key过程一样
                    if(json[i] == '\\') { // 转义符无条件保留它后面一位
                        value += json[i + 1];
                        i ++;
                    }
                    else if(json[i] != '"') value += json[i]; // 其余不是引号都保存
                    i ++;
                }
                tree[tNum].key = key;
                tree[tNum].value = value;
                tree[stk.top()].child.push_back(tNum);
                if(json[i] == '}') stk.pop(); // 遇}出栈
                tNum ++;
                i ++;
                while(i < json.size() && (json[i] == ',' || json[i] == '}')) { // 碰到逗号,直接跳过，碰到}出栈
                    if(json[i] == '}') stk.pop();
                    i ++;
                }
            }
        }
    }while(i < json.size());
}
void query(string s) { // 对s进行查询
    stringstream input(s);
    vector<string> q;
    string tmp;
    while(getline(input, tmp, '.')) { // 按.分割查询
        q.push_back(tmp);
    }
    int root = 0; // root
    string ans;
    for(auto key : q) { // 根的孩子开始查找
        bool isFind = false;
        for(auto i : tree[root].child) { // 遍历孩子
            if(key == tree[i].key) { // 找到
                root = i;
                ans = tree[i].value;
                isFind = true;
                break;
            }
        }
        if(!isFind) { // 不存在
            printf("NOTEXIST\n");
            return;
        }
    }
    if(ans == "OBJECT") printf("OBJECT\n");
    else printf("STRING %s\n", ans.c_str());
}
int main() {
    readData();
    createTree();
    for(int i = 0; i < m; i ++) {
        string s;
        getline(cin, s);
        query(s);
    }
    return 0;
}
```



## [201703-3 Markdown](http://118.190.20.162/view.page?gpid=T55)

### 1 思路分析

​		两个区块之间有一个或多个空行分割，因此在读入时可根据空行来处理当前分块，同时，最后一行之后又没有空行，因此需要特殊处理。用正则表达式来处理分块可降低难度，以下为主要的正则式：

+ **强调**：`_([^_]+)_`表示以下划线开头和结尾，中间至少1个非下划线字符（若是这样写：`_(.+)_`，中间为任意字符的话，当一段字符串同时**有多个强调**时，根据匹配的贪心法则，只会处理第一个和最后一个下划线，如`1_23_4_56_7`处理后为`1<em>23_4_56</em>7`。10个测试样例均有同时包含多个强调。）。
+ **超链接**：`\\[([^\\]]+)\\]\\(([^\\)]+)\\)`：其中`\\[`表示字符`[`，而`[^\\]]+`表示匹配`非]的多个字符`。圆括号同理。（这里与强调一样，需考虑同时存在多个超链接）
+ **标题**：由于标题有最多有6级，因此定义映射headTrans来构造`#`->`1`之间的关系，到时候遍历匹配即可，同时需要去除`#`到内容间的多余空格。
+ **无序列表**：与标题类似，在`*`到内容之间的多余空格需去除。

### 2 注意点

+ 这题嵌套强调和超链接倒不是什么问题，反而是他们自身有多个同时存在导致的坑。
	+ **连续强调**需考虑，如`_e_4_9_`，10个测试点都有。
	+ **连续超链接**需考虑，如`[link1](h1)123[link2](h2)`，1个测试点。
+ 标题和无序列表标记到内容之间的空格需去除。
+ 分块间空行：题目一开始给的转换示意是保留了分块间空行的，但是输出时又明确要求去除这类空格。

### 3 测试样例

```
// input
#   Heading

## Sub-heading

Paragraphs are separeated
by a blank line.

Text attributes _italic_.

Bullet list:

* apples
*   oranges
* pears

A [link](http://example.com).
```

### 4 C++（正则表达式）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-02 18:58:57
 * @LastEditTime: 2019-09-03 06:30:51
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
map<string, string> headTrans = {{"#", "1"}, {"##", "2"}, {"###", "3"}, {"####", "4"}, {"#####", "5"}, {"######", "6"}};
void solve(string& block) { // 处理一块
    if(!block.empty()) {
        block = regex_replace(block, regex("_([^_]+)_"), "<em>$1</em>"); // 强调
        block = regex_replace(block, regex("\\[([^\\]]+)\\]\\(([^\\)]+)\\)"), "<a href=\"$2\">$1</a>"); //超链接
        block.erase(block.end() - 1); // 擦除最后的换行
        if(block[0] == '#') { // 标题
            for(auto mp : headTrans) {
                block = regex_replace(block, regex("^" + mp.first + " +(.+)$"), "<h"+mp.second+">$1</h"+mp.second+">\n");
            }
        }
        else if(block[0] == '*') { // 无序列表
            block = regex_replace(block, regex("\\* +(.+)"), "<li>$1</li>");
            block = "<ul>\n" + block + "\n</ul>\n";
        }
        else block = "<p>" + block + "</p>\n"; // 段落
        cout <<block;
        block.clear();
    }
}
int main() {
    string s, block;
    while(getline(cin, s)) {
        if(!s.empty()) block += (s + "\n");
        else solve(block);
    }
    solve(block); // 处理最后一块
    return 0;
}
```



## [201612-3 权限查询](http://118.190.20.162/view.page?gpid=T50)

### 1 思路分析
​		本题比较容易，令`unordered_map<string, unordered_map<string, int> > role, user`分别存储角色和用户的权限名和等级，其中等级默认为-1，表示不分等级。先读入role，在读入user过程中，直接将user与对应的权限与等级想绑定，便于查询。

### 2 注意点
+ 由于题目保证R段的输入合法，因此P段没有用处，不保存也行。第一次见到多余条件的题。
+ role读入相应权限与等级时遇到同种类的权限取最高等级。user也一样。
+ 都想到用unordered_map了，不知道使用它嵌套，因为没有注意到map其实和数组一样，可以存储多个元素。

### 3 AC代码
​		数据结构的设计直接影响编码复杂度，以下原始和优化的代码对比是恰如其分的说明。

#### 3.1 C++（优化版 STL:unordered_map）

​		[参考博客](https://blog.csdn.net/richenyunqi/article/details/87823905)

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-04 08:28:11
 * @LastEditTime: 2019-09-04 09:26:24
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
unordered_map<string, unordered_map<string, int> > role; // 角色对应的权限名和等级
unordered_map<string, unordered_map<string, int> > user; // 用户对应的权限名和等级
pair<string, int> split(string& s) { // 分割得到权限名和等级
    int pos = s.find(':');
    int level = (pos == string::npos) ? -1 : stoi(s.substr(pos + 1, 1)); // 等级默认-1，表示不分等级
    return make_pair(s.substr(0, pos), level); // 构造序偶对
}
int main() {
    int p, r, s, u, q;
    string s1, s2;
    cin >>p;
    while(p --) cin >>s1; // 权限种类没用，所以不存
    cin >>r;
    while(r --) { // 角色
        cin >>s1 >>s;
        while(s --) {
            cin >>s2;
            pair<string, int> p = split(s2);
            if(role[s1].count(p.first) != 0) role[s1][p.first] = max(role[s1][p.first], p.second); // 取最大
            else role[s1].insert(p);
        }
    }
    cin >>u;
    while(u --) { // 用户
        cin >>s1 >>s;
        while(s --) {
            cin >>s2;
            for(auto p : role[s2]) { // 该角色所有权限
                if(user.count(s1) !=0 && user[s1].count(p.first) != 0) user[s1][p.first] = max(p.second, user[s1][p.first]); // 取大者
                else user[s1].insert(p);
            }
        }
    }
    cin >>q;
    while(q --) { // 查询
        cin >>s1 >>s2;
        pair<string, int> p = split(s2);
        if(user.count(s1) == 0 || user[s1].count(p.first) == 0 || user[s1][p.first] < p.second) printf("false\n");
        else {
            if(p.second == -1 && user[s1][p.first] != -1) printf("%d\n", user[s1][p.first]);
            else printf("true\n");
        }
    }
    return 0;
}
```

#### 3.2 C++（原始版）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-03 21:28:54
 * @LastEditTime: 2019-09-03 23:16:10
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
const int MIN = '*'; // 表示不分等级权限
vector<string> auth; // 权限
unordered_map<string, set<string> > role; // 角色名->(权限名，等级)
unordered_map<string, vector<pair<string, char> > > user; // 用户名->(权限名，等级)

void readData() {
    string str;
    int p, r, s, u;
    scanf("%d", &p);
    for(int i = 0; i < p; i ++) { // 权限段
        cin >>str;
        auth.push_back(str);
    }
    scanf("%d", &r);
    for(int i = 0; i < r; i ++) { // 角色段
        string rname; // 角色名
        cin >>rname;
        scanf("%d", &s); // 权限个数
        for(int j = 0; j < s; j ++) {
            cin >>str;
            role[rname].insert(str);
        }
    }
    scanf("%d", &u);
    string uname;
    for(int i = 0; i < u; i ++) { // 用户段
        cin >>uname; // 用户名
        scanf("%d", &s);
        string rname; // 角色名
        set<string> _set; // 去重判断
        for(int j = 0; j < s; j ++) {
            cin >>rname;
            for(auto str : role[rname]) { // 遍历该角色所有权限，重复出现选最大
                string category;
                char level = MIN;
                int pos = str.find(':');
                if(pos != string::npos) { // 分割类别名和权限
                    category = str.substr(0, str.size() - 2);
                    level = str.back();
                }
                else category = str;
                if(_set.count(category) == 0) { // 第一次出现
                    _set.insert(category);
                    user[uname].push_back({category, level});
                }
                else { // 重复出现
                    for(auto &p : user[uname]) {
                        if(p.first == category) { // 取最大
                            p.second = max(p.second, level);
                        }
                    }
                }
            }
        }
    }
}
void query() {
    int q;
    scanf("%d", &q);
    string uname, str;
    for(int i = 0; i < q; i ++) {
        cin >>uname >>str;
        if(user.count(uname) == 0) printf("false\n");
        else {
            string category;
            char level = MIN;
            int pos = str.find(':');
            if(pos != string::npos) { // 分割类别名和权限
                category = str.substr(0, str.size() - 2);
                level = str.back();
            }
            else category = str;
            bool isFind = false;
            for(auto p : user[uname]) {
                if(p.first == category) {
                    if(p.second < level) printf("false\n");
                    else {
                        if(level == MIN && p.second != MIN) printf("%c\n", p.second);
                        else printf("true\n");
                    }
                    isFind = true;
                    break;
                }
            }
            if(!isFind) printf("false\n");
        }
    }
}
int main() {
    readData();
    query();
    return 0;
}
```



## [201609-3 炉石传说](http://118.190.20.162/view.page?gpid=T45)

### 1 思路分析

​		思路比较简单，使用`vector<pair<int, int> > player[2]`存储正反两个玩家对应角色的攻击力和生命值。用vector的insert和erase函数完成指定位置的插入删除（在此前vector需初始化，否则会溢出）。
### 2 注意点
+ 执行攻击动作时，必须先将正反两方的生命值都计算出来后，才能删除死亡的非英雄角色，若先删除一个死亡英雄，那么计算下个角色的生命值就不对了（英雄不可删除）。
+ 由于保证一个英雄死亡后无操作，且英雄只能被攻击，说明一定不会有平局。
+ 这里vector需要初始化，否则插入容易溢出（不初始化其实也能AC，因为测试样例没考虑这点）。
+ 一般涉及较多的插入删除使用链表比较合适，但链表缺点在于只能通过迭代器访问，且迭代器只能通过自增，因此不适合本题随机插入。

### 3 C++(vector模拟)

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-04 19:29:11
 * @LastEditTime: 2019-09-04 21:39:29
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
vector<pair<int, int> > player[2] = {{{0, 30}}, {{0, 30}}}; // 正反两个玩家攻击和生命
int main() {
    player[0].resize(10); // 初始化
    player[1].resize(10);
    string action;
    int now = 0, n, pos, a, h, d;
    cin >>n;
    while(n --) {
        cin >>action;
        if(action == "summon") {
            cin >>pos >>a >>h; // 位置，攻击力，生命值
            player[now].insert(player[now].begin() + pos, {a, h});
        }
        else if(action == "attack") {
            cin >>a >>d;
            auto& atk = player[now], &dfd = player[(now + 1) % 2]; // 正反方
            atk[a].second -= dfd[d].first; // 必须先攻击完再去删除死亡
            dfd[d].second -= atk[a].first;
            if(atk[a].second <= 0 && a != 0) { // 死亡且不是英雄，删除它
                atk.erase(atk.begin() + a);
            }
            if(dfd[d].second <= 0 && d != 0) {
                dfd.erase(dfd.begin() + d);
            }
        }
        else now = (now + 1) % 2; // 正反方轮换
    }
    if(player[0][0].second > 0 && player[1][0].second > 0) printf("0\n");
    else if(player[0][0].second > 0) printf("1\n");
    else printf("-1\n");
    for(int i = 0; i < 2; i ++) {
        printf("%d\n", player[i][0].second);
        vector<int> ans;
        for(int j = 1; j < 8; j ++) {
            if(player[i][j].second > 0) ans.push_back(player[i][j].second);
        }
        printf("%d", ans.size());
        for(auto p : ans) printf(" %d", p);
        printf("\n");
    }
    return 0;
}
```

### 4 总结

​		上了大三，学了专业课，发现真的好不一样，老师都好厉害，思维方式都改变了。今天上软件测试，明白了需求规格分析才是根本，放到这里，同样适用，只要我把题目的需求（要求）捋清楚，那么编码其实是很容易的事。所以，以后遇到很长的题，先弄明白要干什么，再去coding。



## [201604-3 路径解析](http://118.190.20.162/view.page?gpid=T40)

### 1  思路

​		步骤 1：以string型变量nowPath存储当前路径。若当前需正规化路径为空，直接输出当前路径；否则进入步骤2。
​		步骤 2：若字符串s不以`/`开头，即以相对路径开头，拼接当前路径与s，中间以`/`分割，得到新s。用stringstream以`/`来分割字符串s，若得到的字符串tmp为`.`，直接忽略；若tmp不为`..`，将其压入string类型容器ans中；若tmp为`..`且ans非空，弹出尾部元素。
​		步骤 3：最终ans中存储的是除了根目录以外路径的各个部分，按要求输出即可。

### 2  注意点

+ 若用正则表达式处理，会超时，仅90分。
+ 本题有些像栈，不用使用vector容器模拟更方便。

### 3  代码

#### 3.1 C++（vector模拟栈，100分）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-05 20:52:26
 * @LastEditTime: 2019-09-05 21:11:12
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
string nowPath;
int main() {
    int n;
    cin >>n >>nowPath;
    getchar();
    string s, tmp;
    while(n --) {
        getline(cin, s);
        if(s.empty()) printf("%s\n", nowPath.c_str()); // 空串输出当前路径
        else {
            vector<string> ans;
            if(s[0] != '/') s = nowPath + "/" + s; // 非绝对路径直接加上当前路径
            s = regex_replace(s, regex("(//+)"), "/"); // 正则将//+替换为/
            stringstream input(s.substr(1));
            while(getline(input, tmp, '/')) { // 分割路径
                if(tmp == ".") continue;
                else if(tmp == "..") {
                    if(!ans.empty()) ans.pop_back();
                }
                else ans.push_back(tmp);
            }
            printf("/");
            for(int i = 0; i < ans.size(); i ++) 
                printf("%s%s", ans[i].c_str(), i == ans.size() - 1 ? "\n" : "/");
            if(ans.size() == 0) printf("\n"); // 根目录特判
        }
    }
    return 0;
}
```

#### 3.2 C++（正则表达式，90分）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-05 09:26:11
 * @LastEditTime: 2019-09-05 20:45:43
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
string now, pre, s;
char str[1010];
int main() {
    int n;
    cin >>n >>now;
    getchar();
    while(n --) {
        fgets(str, 1010, stdin);
        s = str;
        s.erase(s.end() - 1);
        if(s.empty()) cout <<now <<endl;
        else {
            if(s[0] != '/') s = now + "/" + s; // 非绝对路径
            s = regex_replace(s, regex("(//+)"), "/");
            while(true) { // /../ -> /**/，与文件中的.区别
                string tmp = s;
                s = regex_replace(s, regex("(/\\.\\./)"), "/**/");
                if(s == tmp) break;
            }
            while(true) { // /./ -> /
                string tmp = s;
                s = regex_replace(s, regex("(/\\./)"), "/");
                if(s == tmp) break;
            }
            while(true) {
                string tmp = s;
                s = regex_replace(s, regex("((^/\\*\\*)|(/[^/]+/\\*\\*))"), "");
                if(tmp == s) break;
            }
            if(s == "/") printf("/\n");
            else {
                if(s.back() == '/') printf("%s\n", s.substr(0, s.size() - 1).c_str());
                else printf("%s\n", s.c_str());
            }
        }
    }
    return 0;
}
// /d2/d3/../d1/../../d2 
// ../1/..d.2./././.././
```

### 4 总结

​		一开始用正则表达式只有60分，因为没考虑到文件|目录存在`.`，与特殊字符混在一起，导致正则失效，后来想把文件|目录中的`.`改为未出现的`*`，发现难以区分。接着灵光一闪，用正则表达式把`/../`改为`/**/`，就好办多了。但是最后一个点超时了，可见正则表达式效率极低。

​		正则表达式两缺点：太慢；复杂匹配容易重复交叉，不容易发现问题。



## [201512-3 画图](http://118.190.20.162/view.page?gpid=T35)

### 1  思路

		总体比较简单，用N*M的数组保存图，注意以下问题：

+ **坐标变换**：题目坐标（笛卡尔坐标）`(x,y)`->左上角为原点的坐标`(x,n-1-y)`->数组坐标`(n-1-y,x)`。
+ **填充**：bfs/dfs均可实现，遇到`- | +`停止。
+ **横线/竖线**：注意**包括两个端点**，`-`遇到`|`改为`+`，遇到非`+`，置为`-`。`|`与其类似。

### 2  注意点

+ 注意输出格式，不需空格，原样输出矩阵即可。

### 3  C++（矩阵模拟+BFS）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-06 08:31:20
 * @LastEditTime: 2019-09-06 14:46:44
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
int m, n, q;
char a[101][101];
int X[4] = {0, 0, -1, 1}; // X,Y配合作为向量，即上下左右四个方向
int Y[4] = {1, -1, 0, 0};
void print(int n, int m) { // 打印图像
    for(int i = 0; i < n; i ++) {
        for(int j = 0; j < m; j ++) {
            printf("%c", a[i][j]); // 别习惯加空格
        }
        printf("\n");
    }
}
void bfs(int x, int y, char ch) { // bfs填充，队列模拟
    queue<pair<int, int> > q;
    a[x][y] = ch; // 入队前标记
    q.push({x, y});
    pair<int, int> p;
    while(!q.empty()) {
        p = q.front();
        q.pop();
        for(int i = 0; i < 4; i ++) { // 4个方向
            int curX = p.first + X[i], curY = p.second + Y[i];
            if(curX >= 0 && curX < n && curY >= 0 && curY < m) { // 界内
                char tmp = a[curX][curY];
                if(tmp != '-' && tmp != '|' && tmp != '+' && tmp != ch) { // 非线段且未填充
                    a[curX][curY] = ch;
                    q.push({curX, curY});
                }
            }
        }
    }
}
void horizon(int y, int x1, int x2) { // 水平线
    int left = min(x1, x2), right = max(x1, x2);
    for(int x = left; x <= right; x ++) {
        if(a[y][x] == '|') a[y][x] = '+';
        else if(a[y][x] != '+') a[y][x] = '-';
    }
}
void vertical(int x, int y1, int y2) { // 垂直线
    int down = min(y1, y2), up = max(y1, y2);
    for(int y = down; y <= up; y ++) {
        if(a[y][x] == '-') a[y][x] = '+';
        else if(a[y][x] != '+') a[y][x] = '|';
    }
}
int main() {
    fill(a[0], a[0] + 101 * 101, '.'); // 初始化.
    scanf("%d %d %d", &m, &n, &q);
    int t, x1, y1, x2, y2, x, y, c;
    while(q --) {
        scanf("%d", &t);
        if(t == 0) {
            scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
            if(y1 == y2) { // 水平
                horizon(n - 1 - y1, x1, x2); // 笛卡尔坐标->矩阵坐标->数组坐标
            }
            else { // 垂直
                vertical(x1, n - 1 - y1, n - 1 - y2);
            }
        }
        else { // 填充
            scanf("%d %d %c", &x, &y, &c);
            bfs(n - 1 - y, x, c);
        }
    }
    print(n, m);
    return 0;
}
```



## [201509-3 模板生成系统](http://118.190.20.162/view.page?gpid=T30)

### 1  思路分析

		这是一道绝佳的字符串练习，可用正则表达式或直接处理。
	
		步骤 1：用fgets读入每一行，并拼接在string类型的s后（包括换行）。定义map<string,string>mp存储变量名到变量值，其中变量值需去除两端的双引号。
	
		步骤 2：接着有3种做法，具体如下：

（1）利用正则表达式在所有`{{前和}}后`添加字符\`, 然后使用stringstream根据字符\`来分割字符串s得到一个个子串tmp，若tmp符合变量格式，利用正则表达式取出变量，若其在mp存在，直接输出相应值，否则跳过；若不符合变量格式，直接输出tmp即可（这有一点投机取巧，就是赌测试样例中不含字符\`，因此又参考练习以下两种思路）。

（2）利用正则表达式搜索功能，一个个找匹配的变量，找到后处理方式与（1）相同。

（3）思路与（2）一样，不过单纯使用find函数实现，效率最高。

		这3种思路的AC代码如下：

### 2  三种思路AC代码

#### 2.1  C++（正则表达式添加字符分割）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-06 18:58:19
 * @LastEditTime: 2019-09-06 20:10:55
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
map<string, string> mp; // 变量 -> 值
string s, var, val, ans, tmp;
int main() {
    int m, n;
    scanf("%d %d", &m, &n);
    getchar();
    char str[1000];
    while(m --) {
        fgets(str, 1000, stdin);
        s += (string)str;
    }
    while(n --) {
        scanf("%s ", str);
        var = str;
        getline(cin, val);
        val = val.substr(1, val.size() - 2);
        mp.insert({var, val});
    }
    s = regex_replace(s, regex("(\\{\\{)"), "`{{");
    s = regex_replace(s, regex("(\\}\\})"), "}}`");
    stringstream input(s);
    while(getline(input, tmp, '`')) {
        smatch res;
        if(regex_match(tmp, res, regex("^\\{\\{ ([^ ]+) \\}\\}$"))) {
            if(mp.count(res.str(1)) != 0) {
                ans += mp[res.str(1)];
            }
        }
        else ans += tmp;
    }
    cout <<ans;
    return 0;
}
```

#### 2.2  C++（正则表达式搜索）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-06 20:29:29
 * @LastEditTime: 2019-09-06 20:56:20
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
map<string, string> mp; // 变量 -> 值
string s, var, val, ans, tmp;
int main() {
    int m, n;
    scanf("%d %d", &m, &n);
    getchar();
    char str[1000];
    while(m --) {
        fgets(str, 1000, stdin);
        s += (string)str;
    }
    while(n --) {
        scanf("%s ", str);
        var = str;
        getline(cin, val);
        val = val.substr(1, val.size() - 2);
        mp.insert({var, val});
    }
    auto i = s.cbegin(); // regex_search需要const_iterator类型变量
    smatch res;
    while(regex_search(i, s.cend(), res, regex("\\{\\{ ([^ ]+) \\}\\}"))) { // 搜索匹配变量
        for(; i != res[0].first; i ++) printf("%c", *i); // 输出匹配前的字符
        if(mp.count(res[1]) != 0) printf("%s", mp[res[1]].c_str()); // 若存在变量，直接输出
        i = res[0].second; // 更换下标，下一次搜索
    }
    for(; i != s.cend(); i ++) printf("%c", *i); // 输出剩余字符
    return 0;
}
```

#### 2.3  C++（单纯find函数）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-06 20:56:55
 * @LastEditTime: 2019-09-06 21:16:04
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
map<string, string> mp; // 变量 -> 值
string s, var, val, ans, tmp;
int main() {
    int m, n;
    scanf("%d %d", &m, &n);
    getchar();
    char str[1000];
    while(m --) {
        fgets(str, 1000, stdin);
        s += (string)str;
    }
    while(n --) {
        scanf("%s ", str);
        var = str;
        getline(cin, val);
        val = val.substr(1, val.size() - 2);
        mp.insert({var, val});
    }
    auto i = 0;
    do {
        auto j = s.find("{{", i), k = s.find("}}", i); // 从i开始找到第一个{{和}}
        if(j != string::npos && k != string::npos) { // 变量存在
            for(; i < j; i ++) printf("%c", s[i]); // 输出从i开始的匹配的变量间字符
            tmp = s.substr(j + 3, k - j - 4); // 变量名
            if(mp.count(tmp) != 0) printf("%s", mp[tmp].c_str()); // 变量名的值存在，直接输出
            i = k + 2; // 更新下标
        }
        else for(; i < s.size(); i ++) printf("%c", s[i]); // 匹配结束，输出剩余字符
    }while(i < s.size());
    return 0;
}
```

### 3  总结

+ 有时直接对字符串处理还更简单，主要用string的find，stringstream，substr在辅助以正则表达式的搜索，匹配，替换。
+ 正则表达式的搜索每次找到第一个符合的就立刻返回，因此需要手动迭代位置，其中smacth的[first,second)表示该匹配子串在原串的下标。而匹配和替换都是一次性处理完整个字符串，得到所有匹配的子串。
+ find也可以搜索字符串，以前一直以为只能搜索字符，还有正则表达式搜索，有许多用法。之所以我不知道，是每次vscode只弹出一个定义，而这些函数有许多个的重载函数，没细看，导致每次只会一点。
+ 正则表达式搜索必须使用const_iterator，真奇葩。



## [201503-3 节日](http://118.190.20.162/view.page?gpid=T25)

### 1  思路分析

		这题是**201712-3 Crontab**的一个简化版，简单的日期处理，需注意以下问题：

+ 闰年判断：仅2月份天数有差别
+ 给定yyyymmdd，计算当前是周几：根据1850/01/01是周2，累加计算求模即可。

### 2  注意点

+ 题目所给星期是从1~7，可将周日用0表示，便于模运算。

### 3  C++（日期处理模板）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-07 08:36:48
 * @LastEditTime: 2019-09-07 09:01:51
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
int monthDays[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 平年月份天数
bool isLeap(int year) {
    return (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);
}
int getMonthDays(int y, int m) { // 获取当前月份的天数
    if(m == 2 && isLeap(y)) return 29;
    else return monthDays[m];
}
int getWeekday(int year, int month, int day) { // 当前日期为周几，根据1850年1月1日周二
    int ret = 2;
    for(int y = 1850; y < year; y ++) { // 年
        int sum = isLeap(y) ? 366 : 365;
        ret = (ret + sum) % 7;
    }
    for(int m = 1; m < month; m ++) { // 月
        int sum = getMonthDays(year, m);
        ret = (ret + sum) % 7;
    }
    return (ret + day - 1) % 7; // 天
}
int main() {
    int a, b, c, _y1, _y2; // y1若定义成全局变量和math库冲突
    scanf("%d %d %d %d %d", &a, &b, &c, &_y1, &_y2);
    if(c == 7) c = 0; // 周天处理为0，便于模运算
    for(int y = _y1; y <= _y2; y ++) { // 每年
        int ret = getWeekday(y, a, 1), cnt = 0; // 当前年月的1号是周几；第几个周c
        for(int d = 1; d <= getMonthDays(y, a); d ++) { // 天
            int tmp = (ret + d - 1) % 7;
            if(tmp == c) cnt ++;
            if(cnt == b) {
                printf("%d/%02d/%02d\n", y, a, d);
                break;
            }
        }
        if(cnt != b) printf("none\n");
    }
    return 0;
}
```



## [201412-3 集合竞价（好题）](http://118.190.20.162/view.page?gpid=T19)

### 1  思路分析

		定价的选择存在一个区间，关键在于发现其取值落于买单中。虽然这看起来是很自然的结论，不过还是可[证明参考](https://blog.csdn.net/AivenZhong/article/details/84195177)。知道定价一定从买单价格中选取后，即枚举每个买单价格p，分别计算出买单价格中大于等于p的交易总量和卖单价格小于等于p的交易总量，选择较小者作为最终成交量。最好遍历每条买单，找出最大的成交量，记录其交易价格作为定价，若存在多个最大成交量，选择交易价格最大的。
	
		定义结构体类型Record表示每条记录的有效性，类型，交易价格，最终成交量。

```cpp
struct Record {
    int valid, type; // 是否有效：0无效，1有效；类型，0：buy， 1：sell
    double p; // 价格
    long long s, bNum, sNum, minNum; // 股数，以p为开盘价的购买股数、售卖股数、买卖最小股数
    Record() {valid = 1; bNum = sNum = 0;} // 默认构造初始化
};
vector<Record> a, buy, sell; // 临时存放、有效买、卖记录
```

### 2  注意点

+ 累计交易量过程可能超出int范围，因此使用longlong类型。
+ cancel i是令第i行记录无效，不是第i条有效记录无效。

### 3  C++（数学递推+sort）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-07 10:31:08
 * @LastEditTime: 2019-09-07 21:01:00
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
struct Record {
    int valid, type; // 是否有效：0无效，1有效；类型，0：buy， 1：sell
    double p; // 价格
    long long s, bNum, sNum, minNum; // 股数，以p为开盘价的购买股数、售卖股数、买卖最小股数
    Record() {valid = 1; bNum = sNum = 0;} // 默认构造初始化
};
vector<Record> a, buy, sell; // 临时存放、有效买、卖记录
int main() {  
    string s, tmp;
    while(getline(cin, s)) { // ctrl+Z暂停
        Record r;
        stringstream input(s);
        input >>tmp;
        if(tmp == "cancel") {
            int idx;
            input >>idx;
            a[idx - 1].valid = 0; // 标记无效
            r.valid = 0; // 自身也无效
        }
        else {
            input >>r.p >>r.s;
            r.valid = 1;
            r.type = (tmp == "buy") ? 0 : 1; // 类型
        }
        a.push_back(r); // 保存
    }
    for(auto& p : a) { // 分离有效买卖记录
        if(p.valid == 1) {
            if(p.type == 0) buy.push_back(p);
            else sell.push_back(p);
        }
    }
    sort(buy.begin(), buy.end(), [](Record& a, Record& b) {return a.p < b.p;}); // 按交易价从小到大排序
    sort(sell.begin(), sell.end(), [](Record& a, Record& b) {return a.p < b.p;});
    double ansP; // 最大交易价格
    long long ans = -1; // 最大成交量
    for(int i = buy.size() - 1; i >= 0; i --) { // 购买股数计算
        buy[i].bNum = (i == buy.size() - 1) ? buy[i].s : buy[i].s + buy[i + 1].bNum;
        for(int j = 0; j < sell.size(); j ++) { // 对当前购买价格p的卖的股数计算
            if(buy[i].p < sell[j].p) break;
            buy[i].sNum += sell[j].s;
        }
        buy[i].minNum = min(buy[i].sNum, buy[i].bNum); // 取小者
        if(buy[i].minNum > ans) { // 更新
            ans = buy[i].minNum;
            ansP = buy[i].p;
        }
    }
    printf("%.2lf %lld\n", ansP, ans);
    return 0;
}
```



## [201409-3 字符串匹配](http://118.190.20.162/view.page?gpid=T14)

### 1  思路分析

		简单子串匹配问题，可直接用**find函数**或**正则表达式的匹配或搜索**实现。具体介绍如下：

（1）**find实现**：若是大小写敏感，统一转换为小写，可用`transform`实现。

（2）**正则表达式实现**：全文匹配或子串搜索

+ **全文匹配regex_match**：关键代码如下，其中`[:alpha:]`表示所有字母，等价于`[a-zA-Z]`，因此`[[:alpha:]]*`表示匹配0个或多个字母。其中`regex::icase`表示大小写不敏感。

```cpp
if(flag == 0 && regex_match(s, regex("[[:alpha:]]*"+dist+"[[:alpha:]]*", regex::icase))) puts(s.c_str());
if(flag == 1 && regex_match(s, regex("[[:alpha:]]*"+dist+"[[:alpha:]]*"))) puts(s.c_str());
```

+ **子串搜索regex_search**：由于子串搜索是全文匹配的一个部分，因此，可直接将上文的`regex_match`直接替换为`regex_serach`，结果如下：

```cpp
if(flag == 0 && regex_search(s, regex("[[:alpha:]]*"+dist+"[[:alpha:]]*", regex::icase))) puts(s.c_str());
if(flag == 1 && regex_search(s, regex("[[:alpha:]]*"+dist+"[[:alpha:]]*"))) puts(s.c_str());
```

		不过这样效率太低，可以直接利用子串搜索的特性，它可以直接搜索指定格式的子串，且搜索到第一个立刻返回，因此效率高于全文匹配。具体如下：

```cpp
if(flag == 0 && regex_search(s, regex(dist, regex::icase))) puts(s.c_str());
if(flag == 1 && regex_search(s, regex(dist))) puts(s.c_str());
```

### 2  注意点

+ regex_match意为全文匹配，因此搜索子串时必须把正则表达式写全；regex_search意为子串搜索，因此搜索子串时正常只写子串格式即可。

### 3  AC代码

#### 3.1  C++（find函数）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-07 21:37:04
 * @LastEditTime: 2019-09-07 21:59:53
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
int main() {
    string dist, tmp, s;
    int flag, n;
    cin >>dist >>flag >>n;
    if(flag == 0) transform(dist.begin(), dist.end(), dist.begin(), [](char c) {return tolower(c);}); //转为小写
    while(n --) {
        cin >>s;
        tmp = s;
        if(flag == 0) transform(tmp.begin(), tmp.end(), tmp.begin(), [](char c) {return tolower(c);}); //转为小写
        if(tmp.find(dist) != string::npos) printf("%s\n", s.c_str());
    }
    return 0;
}
```

#### 3.2  C++（正则表达式）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-07 22:03:51
 * @LastEditTime: 2019-09-07 22:56:28
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
int main() {
    string dist, tmp, s;
    int flag, n;
    cin >>dist >>flag >>n;
    while(n --) {
        cin >>s;
        // if(flag == 0 && regex_match(s, regex("[[:alpha:]]*"+dist+"[[:alpha:]]*", regex::icase))) puts(s.c_str());
        // if(flag == 1 && regex_match(s, regex("[[:alpha:]]*"+dist+"[[:alpha:]]*"))) puts(s.c_str());
        // if(flag == 0 && regex_search(s, regex("[[:alpha:]]*"+dist+"[[:alpha:]]*", regex::icase))) puts(s.c_str());
        // if(flag == 1 && regex_search(s, regex("[[:alpha:]]*"+dist+"[[:alpha:]]*"))) puts(s.c_str());
        if(flag == 0 && regex_search(s, regex(dist, regex::icase))) puts(s.c_str());
        if(flag == 1 && regex_search(s, regex(dist))) puts(s.c_str());
        
    }
    return 0;
}
// [a-zA-Z]*Hello[a-zA-Z]*
```



## [201403-3 命令行选项](http://118.190.20.162/view.page?gpid=T8)

### 1  思路分析

		步骤 1：定义`unordered_map<string, *int*> opt`表示接受选项到带参数与否的映射 ，其中0：不带，1：带。`map<string, string> ans`存放选项和参数，其中令参数为空字符串表示无参数，由于map按key的字典序自动升序，因此最后直接输出即可。
	
		步骤 2：用`stringstream`分割字符串，来进行匹配，一遇到不匹配的子串，立刻退出。

### 2  注意点

+ 参数和选项一样是可以带`-`的。
+ `getline(input,tmp,' ')`等价于`input>>tmp`，都是根据空格来切割。

### 3  C++（unordered_map+map+stringstream）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-08 09:23:46
 * @LastEditTime: 2019-09-08 10:27:46
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
unordered_map<string, int> opt; // 接受选项->带参数与否 ，0：不带，1：带
int main() {
    string s;
    cin >>s;
    int i = 0;
    while(i < s.size()) {
        string tmp = "-";
        tmp.push_back(s[i]);
        if(i < s.size() - 1 && s[i+1] == ':') {
            opt[tmp] = 1;
            i ++;
        }
        else opt[tmp] = 0;
        i ++;
    }
    int n;
    string tmp, arg;
    scanf("%d", &n);
    getchar();
    for(int i = 1; i <= n; i ++) {
        getline(cin, s);
        stringstream input(s);
        getline(input, tmp, ' ');
        map<string, string> ans; // 存放选项和参数结果
        while(getline(input, tmp, ' ')) {
            if(tmp[0] != '-' || opt.count(tmp) == 0) break; // 不是命令选项或没有此命令选项
            if(opt[tmp] == 0) ans[tmp] = ""; // 不带参数
            if(opt[tmp] == 1) { // 带参数
                if(getline(input, arg, ' ')) ans[tmp] = arg; // 更新参数
                else break; // 不存在参数
            }
        }
        printf("Case %d:", i); // 打印
        for(auto& p : ans) {
            printf(" %s", p.first.c_str());
            if(!p.second.empty()) printf(" %s", p.second.c_str());
        }
        printf("\n");
    }
    return 0;
}
```



## [201312-3 最大的矩形](http://118.190.20.162/view.page?gpid=T3)

### 1 思路分析

		暴力枚举：假设最大的高度为MAX，枚举[1,MAX]的高度h，从[1,n]个矩形中依次枚举，累加高度大于等于h且相邻的矩形的个数sum，其面积为h*sum。若存在相邻的矩形高度小于h，表示存在间断点，sum清零。

### 2  C++（暴力枚举）

```cpp
/*
 * @Author: wuyangjun
 * @Date: 2019-09-08 11:01:32
 * @LastEditTime: 2019-09-08 11:25:37
 * @Github: https://github.com/wyjoutstanding
 */
#include <bits/stdc++.h>
using namespace std;
int n, a[1100];
int main() {
    scanf("%d", &n);
    for(int i = 0; i < n; i ++) scanf("%d", &a[i]);
    int MAX = *max_element(a, a + n); // 选出最大高度
    int ans = -1; // 保存结果
    for(int h = 1; h <= MAX; h ++) { // 遍历所有高度
        int sum = 0;
        for(int j = 0; j < n; j ++) { // 计算连续的矩形面积
            if(a[j] >= h) sum += h;
            else { // 产生间断的矩形
                ans = max(ans, sum);
                sum = 0;
            }
        }
        ans = max(ans, sum); // 无间断的矩形
    }
    printf("%d\n", ans);
    return 0;
}
```



## 总结

### 题型分类

		从19年开始倒着做题，难度确实是逐年降低。第三题主要分为五种类型题目，根据出现频率从高到低排列：

+ 字符串处理
+ 图像处理
+ 日期处理
+ 数学规律
+ 流程模拟

### 技术归纳

		只要掌握以下四类技术，目前没有解决不了的问题：

+ string类的stringstream，find，substr
+ 正则表达式的全文匹配，子串搜索和子串替换
+ string的类型转换stox，ssccanf/sprintf类型转换
+ STL的vector，map，unordered_map，stack，queue，set，sort

### 需求获取（关键）

		根据以上分析可知，题目类型较固定，仅五种，主要是字符串处理（17占9）；技术比较单一，仅4类。各类题型及其相应的解决技术是容易掌握的，关键在于最初的审题，即获取需求。若是一开始需求理解错误或理解不全，将会导致0分或无法满分，因此，需求获取至关重要。
	
		如何获取正确且全面的需求？这个需要积累与细心，通过软件测试来辅助验证需求理解是否正确。