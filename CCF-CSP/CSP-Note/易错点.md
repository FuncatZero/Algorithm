# 踩坑记录

​		本文主要记录平时编程遇到的坑点，俗话说，踩遍所有的坑，成就伟大程序猿。

## 第 1 章 编程语言坑

### 1.1 全局变量慎用

#### 1.1.1 案发现场

​		在编写[201812-3 CIDR合并](http://118.190.20.162/view.page?gpid=T82)这题时，由于使用了结构体类型的全局变量prefIP来存储读入的前缀IP，其中结构体中的数组a[4]的默认值为0，假设第一次读入的a[]={1,2,3,4}，而第二次读入的值为`0/8`，那么在之前的基础上此时a[]={0,2,3,4}，然而正确答案应该是a[]={0,0,0,0}，就是因为没有及时更新，导致前面的值感染了后面的数据。

#### 1.1.2 解剖现场

​		让我们分析下需要**重复更新的变量**在什么场景易出现遗留感染，既然主角是变量，那么考虑它的两个重要因素：**作用域和类型**。作用域常见有**局部**和**全局**，类型可分为**原子类型**（基本数据类型int，float等）和**复合类型（**结构体），根据排列组合可知有4种情况。如果是原子类型，那么无论是局部或全局类型，绝不会忘记更新它。但若是全局复合类型，那么可能存在更新其中一个字段，但是由于疏忽，忘记更新其它字段，导致如上的遗留感染问题。因此，使用局部复合类型，每次使用前定义，这样可有效避免因忘记导致的遗留感染。

#### 1.1.3 反思归纳

​		根据以上分析，可得以下结论：(**局部优先**)

+ 频繁使用的原子类型可定义为全局，否则定义为局部
+ 若非必要，优先定义**复合类型为局部**，降低遗留感染。

### 1.2 右移位数有限（巨坑）

#### 1.2.1 案发现场

​		在编写[201812-3 CIDR合并](http://118.190.20.162/view.page?gpid=T82)这题时，最后一个测试样例包含`255.255.255.255`，在计算匹配集时`0xffffffff>>32`会溢出为-1，导致区间错误。

#### 1.2.2 解剖现场

​		眼见不一定为实，程序中`0xffffffff>>32`输出结果为-1，但实际上并不是溢出问题，而是右移的位数必须小于左边数值的最大位数，否则行为无定义，即可能会变成任意数。无符号数最大位数为32，因此它的右移位数必须小于32，这里等于32自然发生了无定义事件，输出为-1只是一个随机值，与具体编译器相关。

#### 1.2.3 反思归纳

+ 假设x>>n，那么n必须小于x的最大位数，即sizeof(x)\*8。以后右移前先判断范围是否合理。

### 中坑

#### 运算符优先级

+ `& ^ |`的优先级低于关系运算符`== > < >= <= !=`，记得加括号
+ 算术运算符>**关系**运算符>**位运算符（&^|）**>**逻辑运算符(!&&||)**>条件表达式(?:)>赋值运算符
+ getline/fgets使用前需注意用getchar吸收换行；相应的substr取子串需注意去除换行。

#### 正则表达式

+ **贪心匹配，总是找到满足条件的最大字符串**。