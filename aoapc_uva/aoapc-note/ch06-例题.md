# 《算法竞赛入门经典第2版》题解系列 第六章 数据结构基础-例题

## 例题题解分类索引

**[OJ网址点这里](https://vjudge.net/problem)**

紫书刷题进行中，题解系列【[GitHub](https://github.com/wyjoutstanding/Algorithm/tree/master/aoapc_uva)|[CSDN](https://blog.csdn.net/qq_40738840/article/details/104175021)】

本章题目设计诸多数据结构

+ 线性表：栈，队列，链表（掌握基础的增删改查，灵活使用）
+ 关系结构：树和图（set，map底层均为树实现，最强大的关系描述模型）

同时涉及诸多技巧，如**离散化，做差法，隐式建树（启发：做提前问问自己又没必要建立真正的数据结构，只用逻辑结构是否足以解决问题）**，这些东西只看是学不会的（排除天才:），循序渐进的挑战才会进步，因此，在分类栏中标记为`好题，思维题，超好题`的题目需重视，十分锻炼自身思维和编码能力，做好题的重要性不言而喻。

**先享受分析问题的过程（脑力活），然后才是愉快的写代码（体力活）；常分析，常总结，做题愉快！！！**

| 书中编号 | 题目编号 | 标题（题解链接）                                             | 分类       | 备注                                                        |
| -------- | -------- | ------------------------------------------------------------ | ---------- | ----------------------------------------------------------- |
| 例题6-1  | UVA210   | [Concurrency Simulator](#例题6-1-uva210-concurrency-simulator) | 中级模拟   | 并发背景；双端队列；队列；map                               |
| 例题6-2  | UVA514   | [Rails](#例题6-2-uva514-rails)                               | 简单模拟   | 栈妙用（逆向思维）                                          |
| 例题6-3  | UVA442   | [Matrix Chain Multiplication](#例题6-3-uva442-matrix-chain-multiplication) | 简单模拟   | 矩阵链相乘（栈处理括号）                                    |
| 例题6-4  | UVA11988 | [Broken Keyboard](#例题6-4-uva11988-broken-keyboard)         | 简单模拟   | list插入，遍历                                              |
| 例题6-5  | UVA12657 | [Boxes in a Line](#例题6-5-uva12657-boxes-in-a-line)         | 优化技巧   | list插入，遍历；**链表反转标记优化**                        |
| 例题6-6  | UVA679   | [Dropping Balls](#例题6-6-uva679-dropping-balls)             | 规律优化   | 完全二叉树，找规律，时空优化                                |
| 例题6-7  | UVA122   | [Trees on the level](#例题6-7-uva122-trees-on-the-level)     | 树         | 二叉树建立；层次遍历                                        |
| 例题6-8  | UVA548   | [Tree](#例题6-8-uva548-tree)                                 | 树         | 中后序建树；dfs                                             |
| 例题6-9  | UVA839   | [Not so Mobile](#例题6-9-uva839-not-so-mobile)               | 树         | 先序建树，后序判断；**隐式建树判断**                        |
| 例题6-10 | UVA699   | [The Falling Leaves](#例题6-10-uva699-the-falling-leaves)    | 树         | 类似UVA839                                                  |
| 例题6-11 | UVA297   | [Quadtrees](#例题6-11-uva297-quadtrees)                      | 思维题     | **四叉树转二维数组合并**；隐式建树；空间换时间              |
| 例题6-12 | UVA572   | [Oil Deposits](#例题6-12-uva572-oil-deposits)                | 图遍历     | dfs求连通块                                                 |
| 例题6-13 | UVA1103  | [Ancient Messages](#例题6-13-uva1103-ancient-messages)       | 思维题     | 不变特征量；双重dfs；分离连通块；                           |
| 例题6-14 | UVA816   | [Abbott's Revenge](#例题6-14-uva816-abbott's-revenge)        | **bug中**  | bug中                                                       |
| 例题6-15 | UVA10305 | [Ordering Tasks](#例题6-15-uva10305-ordering-tasks)          | 拓扑排序   | queue；n!=0,m=0特例                                         |
| 例题6-16 | UVA10129 | [Play on Words](#例题6-16-uva10129-play-on-words)            | 欧拉路径   | 连通图判断（dfs/并查集）；有向图欧拉路判定条件              |
| 例题6-17 | UVA10562 | [Undraw the Trees](#例题6-17-uva10562-undraw-the-trees)      | 思维题     | 字符串解析/建树/先序-->数组直接递归输出（不建树）           |
| 例题6-18 | UVA12171 | [Sculpture](#例题6-18-uva12171-sculpture)                    | **超好题** | **离散技巧**；**逆向思维/作差法**；floodfill(bfs)；方向向量 |
| 例题6-19 | UVA1572  | [Self-Assembly](#例题6-19-uva1572-self-assembly)             | 好题       | 逆向思维；**无限判定->图判环(dfs/bfs)**；哈希函数           |
| 例题6-20 | UVA1599  | [Ideal Path](#例题6-20-uva1599-ideal-path)                   | 好题       | **双向bf**s；边缓存优化；最短+字典序最小                    |
| 例题6-21 | UVA506   | [System Dependencies](#例题6-21-uva506-system-dependencies)  | 中级模拟   | 字符串处理；命令处理；背景有实际意义                        |
| 例题6-22 | UVA11853 | [Paintball](#例题6-22-uva11853-paintball)                    | 好题       | **条件转换**；**逆向思维**；连通块dfs；条件简化             |



## 例题6-1 UVA210 Concurrency Simulator

### 题目大意

> 题目难懂，仔细读题

给定若干个程序，每个程序包含若干条指令，给出每个命令执行所需时间和每个程序的可用时间，模拟指令执行输出相应信息。

五条指令如下：

+ `variable = constant`：赋值语句，变量`variable`为**单字符**（26个小写字母，**全局共享**），**初值为0**，常量`constant`为小于100的整数
+ `print variable`：打印变量值
+ `lock`：上锁，独占变量资源
+ `unlock`：解锁，接触独占变量资源
+ `end`：程序结束

模拟过程中存在两个队列：

- **ready**：准备队列，依次执行该队列的程序
- **block**：阻塞队列，当**已有**程序进入lock，其它程序**再次遇到lock**指令时，需将该程序插入block末尾；当有程序执行unlock后，将block队首加入ready队首

**注意1：当目前指令执行所需时间大于剩余可用时间时，也要完整执行**

### 思路分析

主要是队列和双端队列模拟，因此定义如下数据结构，队列q1表示每个程序对应的指令，双端队列qr表示ready队列，存储各个程序的编号；qb为阻塞队列，存储被阻塞的程序编号

```cpp
queue<string> q1[a[0]]; deque<int> qr; queue<int> qb; // 每个程序对应指令；ready；阻塞
```

为了处理全局变量，定义`map<string, string> vmp;`表示变量对应的值，注意给26个小写字母初始化为0

其余只需按照每个命令对应的操作处理即可，仅涉及队列的插入和删除，详见代码注释

### 注意点

+ 初始化26个字母对应的值为0
+ 访问和出队时注意先判断队列是否为空
+ 测试样例漏了第一行的测试用例个数
+ 当目前指令执行所需时间大于剩余可用时间时，也要完整执行
+ 当遇到阻塞，lock这条指令不算被执行，依旧保留在源程序，一块加入阻塞队列

### AC代码（C++11，双端队列，字符串处理）

```cpp
#include<bits/stdc++.h>
using namespace std;
int T, a[7]; // 测试用例个数，a[0-6]分别表示输入的7个数
string s, ans;
int main() {
    cin >>T;
    for (int i = 0; i < T; i ++) {
        for (int j = 0; j < 7; j ++) scanf("%d", &a[j]);
        getchar(); // 吸收多余字符
        queue<string> q1[a[0]]; deque<int> qr; queue<int> qb; // 每个程序对应指令；ready；阻塞
        for (int j = 0; j < a[0]; j ++) { // n个程序
            while (getline(cin, s) && s != "end") q1[j].push(s);
            qr.push_back(j);
        }
        if (i != 0) puts(""); // 连续输出的空行
        map<string, string> vmp; // 变量对应的值
        bool isLock = false; // 标记是否有锁
        while (!qr.empty()) { // 等待队列非空
            int t = 0, k = qr.front(); qr.pop_front(); // 耗费时间，当前程序编号
            bool isBlock = false; // 标记是否发生阻塞
            while (t < a[6] && !q1[k].empty()) { // 未超时
                s = q1[k].front(); // 取出第一条命令
                int j = s.find('=');
                if (j != string::npos) { // 赋值
                    vmp[s.substr(0,j-1)] = s.substr(j+2);
                    t += a[1]; // 计时
                }
                else {
                    j = s.find(' ');
                    if (j != string::npos) { // 打印输出
                        ans = "0"; // 初始化
                        if (vmp[s.substr(j+1)] != "") ans = vmp[s.substr(j+1)];  
                        printf("%d: %s\n", k+1, ans.c_str()); // print val
                        t += a[2];
                    }
                    else {
                        if (s[0] == 'l') { // lock
                            if (!isLock) { // 未有锁定
                                isLock = true;
                                t += a[3]; // 时间增加
                            }
                            else { // 已有锁定
                                qb.push(k); // 加入阻塞队列尾部
                                isBlock = true;
                                break; // 直接退出，忽略其它剩余时间
                            }
                        }
                        else if (s[0] == 'u') { // unlock
                            isLock = false; // 标记未锁定
                            if (!qb.empty()) { // 阻塞非空
                                qr.push_front(qb.front()); // 阻塞头部加入ready头部
                                qb.pop();
                            }
                            t += a[4];
                        }
                    }
                }
                q1[k].pop(); // 确保阻塞时lock命令不会被删除
            }
            if (!q1[k].empty() && !isBlock) qr.push_back(k); // 非空再次加入等待队列尾部
        }
    }
    return 0;
}
```

## 例题6-2 UVA514 Rails

### 题目大意

给定包含n个数字的序列A，问数字序列B（1~n顺序排列）能否通过一个栈改变顺序来得到A。通过栈改变顺序时不可出现穿越数字。

### 思路分析

很自然的用栈来模拟整个过程，用j记录目标序列a和模拟序列连续相同个数，枚举1-n，先压入栈中，若栈顶等于a[j]，则退栈，并且j++，继续比较下一个栈顶。

若最后栈为空，表示合法；否则，非法

### AC代码（C++11，栈妙用）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a[1010];
int main() {
    while (cin >>n && n != 0) {
        while (cin >>a[1] && a[1] != 0) {
            for (int i = 2; i <= n; i ++) scanf("%d", &a[i]); // 输入
            stack<int> stk; // 模拟栈
            int j = 1; // 判断联系满足的个数
            for (int i = 1; i <= n; i ++) { // 1-n依次压入
                stk.push(i); // 压栈
                while (!stk.empty() && stk.top() == a[j]) stk.pop(), j ++; // 当栈非空且栈顶为a[j]时，出栈
            }
            printf("%s\n", stk.empty() && j == n+1 ? "Yes" : "No"); // 栈空表示合法
        }
        puts(""); // 两组间空行
    }
    return 0;
}
```

## 例题6-3 UVA442 Matrix Chain Multiplication

### 题目大意

求矩阵在不同乘法顺序下的乘法次数，假设矩阵A：a*b，矩阵B：b\*c，那么A\*B的乘法总次数为a\*b\*c

### 思路分析

矩阵链相乘是动态规划中的典例，可快速计算相乘次数最少的相乘方式，这里比较简单，只需求给定顺序的相乘次数，主要在于括号处理，可用栈轻松实现。

由题目给出的EBNF可知，**每个括号内部一定只有两个矩阵**，因此同一级括号内部个数确定，无需在存储括号。即遇到矩阵压栈，遇到右括号将弹出两个栈顶，计算后再次压入，遇到左括号不处理。

若是每个括号内矩阵个数未知，则必须根据括号来标记同一层级的位置

### AC代码（C++11，stack）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a, b;
char ch;
map<char, pair<int,int> > mp; // 矩阵->（行数，列数）
int simu(string s) { // 模拟相乘过程，错误返回-1，否则返回次数
    int ans = 0;
    stack<pair<int,int> > stk; // 矩阵栈，第一二维
    bool isErr=false; // 标记是否有错误
    for (auto c : s) {
        if (isalpha(c)) stk.push(mp[c]); // 矩阵
        if (c == ')') { // 出栈计算
            auto p1 = stk.top(); stk.pop();
            auto p2 = stk.top(); stk.pop();
            if (p2.second != p1.first) { // 错误
                isErr = true;
                break;
            }
            ans += p2.first*p2.second*p1.second; // 运算次数
            stk.push({p2.first, p1.second}); // 重新压入
        }
    }
    return ans = (isErr) ? -1 : ans;
}
int main() {
    scanf("%d", &n);
    while (n --) {
        getchar();
        scanf("%c %d %d", &ch, &a, &b);
        mp[ch] = {a,b};
    }
    string s;
    while (cin >>s) {
        int ans = simu(s);
        if (ans == -1) puts("error");
        else printf("%d\n", ans);
    }
    return 0;
}
```

## 例题6-4 UVA11988 Broken Keyboard

### 题目大意

给定字符串，当输入`[`时，光标移动到首，当输入`]`时，光标移动到尾，给出移动后的字符串

### 思路分析

链表的插入模拟，list可轻松实现，详见代码注释

若想手动实现，静态链表和动态链表均可，注意开头和结尾的处理

### AC代码（C++11，list）

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int main() {
    while (cin >>s) {
        list<char> l;
        auto p = l.begin(); // 初始化
        for (auto ch : s) {
            if (ch == '[') p = l.begin(); // 开头
            else if (ch == ']') p = l.end(); // 结尾
            else {
                p = l.insert(p, ch); // 返回插入数据的迭代器
                p ++; // 后移一位
            }
        }
        for (auto ch : l) cout <<ch; // 输出
        puts("");
    }
    return 0;
}
```

## 例题6-5 UVA12657 Boxes in a Line

### 题目大意

对升序排列的n个数字（1开始编号）进行一系列操作，输出最终序列的奇位数之和。操作如下：

+ `1 X Y`：把X移到Y左侧
+ `2 X Y`：把X移到Y右侧
+ `3 X Y`：交换X和Y
+ `4`：反转序列（逆置）

### 思路分析

若是直接用链表模拟，在**查找和反转**时会消耗大量时间，导致超时，因此，如何解决这两个问题是关键。

+ 查找：为了简化，可用STL的list模拟链表，同时定义pos存储每个数对应的链表指针，在查询时时间复杂度为O(1)

```cpp
vector<list<int>::iterator> pos(n+1);
```

+ 反转：不一定真正去反转链表，可定义开关标记`inv=0`，其中`inv=1`表示反转一次，再次反转则`inv=0`，由于增加了标记，那么每个操作均需考虑标记的值，当`inv=1`时，考虑如下情况：
  + 当op=1或2时，则需做相反操作，即op=3-op
  + 当op=3时，交换不受影响
  + 当op=4时，`inv=0`
  + 当输出时，若链表个数为偶数，则输出下标为偶数的元素和；否则均输出奇数下标的元素之和

### 注意点

+ 最后计算总和时需用long long保存，否则会溢出

### AC代码（C++11，链表，反转标记优化）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, op, a, b, num=0;
int main() {
    while (scanf("%d %d", &n, &m) == 2) {
        list<int> l(n); // 存储1-n
        vector<list<int>::iterator> pos(n+1); // pos[i]表示数字i在list中的指针
        int idx=1, inv=0;
        for (auto p=l.begin(); p != l.end(); p++, idx++) { // 初始化
            *p = idx;
            pos[idx] = p;
        }
        for (int i = 0; i < m; i ++) { // m个操作
            scanf("%d", &op);
            if (op != 4) scanf("%d %d", &a, &b);
            if (op == 4) inv = !inv; // 反转标记
            else if (op == 3) swap(*pos[a],*pos[b]), swap(pos[a], pos[b]); // 交换
            else {
                l.erase(pos[a]); // 先擦除
                if (inv == 1) op = 3 - op; // 反转则左右交换
                auto p=pos[b];
                if (op == 2) p ++; // 插入右侧
                pos[a] = l.insert(p, a); // a的新位置
            }
        }
        long long cnt=1, oddsum=0; // 避免溢出
        for (auto p=l.begin(); p != l.end(); p++, cnt++) {
            if (cnt % 2 == 1) oddsum += *p;
        }
        printf("Case %d: %lld\n", ++num, (inv == 1 && n%2 == 0) ?  (long long)n*(n+1)/2-oddsum : (long long)oddsum);
    }
    return 0;
}
```



## 例题6-6 UVA679 Dropping Balls

### 题目大意

现有一个D层高的满二叉树，小球从根开始向下滚落，直至叶子结点，每个结点有开关标志flag（初值为false），滚落时左右子树选择规则如下

+ flag=false：flag置为true，向左子树滚落
+ flag=true：flag置为false，向右子树滚落

现求第I个小球落在那个叶子结点

### 思路分析

直接用静态数组依次模拟I个小球滚落，会超时。因此需要找规律来优化时间，有以下结论：

> 假设第i个小球Qi是第j个经过结点Vn，可根据j来判断小球下一个走向，若j为偶数，走右子树；否则，走左子树

假设当前结点为根节点，即V1，那么第1个小球走左子树，第二个走右子树，以此类推

假设当前结点为V2，第1，2,3个经过V2的小球为Q1,Q3,Q5，抽象成公式即`j=(i+1)/2`

假设当前结点为V3，第1，2个经过V2的小球为Q2,Q4，抽象为公式：`j=i/2`

通过这种方式，可以仅根据I的奇偶性依次判断，时间复杂度为O(logn)，并且节省空间

### AC代码（C++11，完全二叉树，规律优化）

```cpp
#include<bits/stdc++.h>
using namespace std;
int T, D, I;
int main() {
    scanf("%d", &T);
    while (T --) {
        scanf("%d %d", &D, &I);
        long long ans=1;
        for (int i = 1; i <= D-1; i ++) { // 模拟I个小球掉落
            if (I % 2 == 1) { // I表示第几个经过当前点
                I = (I+1)/2; // 更新
                ans *= 2;
            }
            else { // 偶数走右子树
                I /= 2;
                ans = ans*2 + 1;
            }
        }
        printf("%lld\n", ans);
    }
    scanf("%d", &T); // 最后的-1，多余的输入！
    return 0;
}
```

## 例题6-7 UVA122 Trees on the level

### 题目大意

给定若干个节点，构建一个二叉树，层次遍历打印结点值。其中结点值和位置以`(value,path)`，value为整型值，path为从根到当前结点的路径，如`LRR`，表示`左右右`。

### 思路分析

很常规的问题，分割字符串得到值和路径，在构建树的过程中注意创建没有的结点，定义结点的结构体如下，其中`assignCnt`记录当前结点被赋值的次数，便于处理未赋值和多次赋值情况。这里不写默认构造函数，而是直接给结构体成员赋初始值（偷个懒：）

```cpp
struct Node {
    int val, assignCnt=0; // 值，被赋值次数
    Node *l=NULL, *r=NULL; // 左右子树
};
```

层次遍历用一个队列处理即可

### 注意点

+ 树根必须先创建结点，否则树根一直指向空，导致后续建树无法连接
+ 建树过程中，注意左右子树若为空，必须以`root->l=new Node`方式创建结点，否则先`root=root->l`再`root=new Node`将导致树连接断裂
+ 以上两种均导致建树失败，注意指针和引用区别，传值和传址

### AC代码（C++11，建树，层次遍历）

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node {
    int val, assignCnt=0; // 值，被赋值次数
    Node *l=NULL, *r=NULL; // 左右子树
};
Node* btree=NULL; // 二叉树根
void insertNode(string s, Node* root) { // 根据路径s插入节点
    int i = s.find(',');
    string ds=s.substr(i+1,s.size()-i-1-1); // 方向
    for (int j=0; j < ds.size();  j++) { // 遍历路径
        if (ds[j] == 'L') {
            if (root->l == NULL) root->l = new Node; // 必须创建节点，否则连接会断开
            root = root->l;
        }
        else if (ds[j] == 'R') {
            if (root->r == NULL) root->r = new Node;
            root = root->r;
        }
    }
    root->val = stoi(s.substr(1,i)); // 赋值
    root->assignCnt ++; // 赋值次数累计
}
void layerTra(Node* root) { // 层次遍历
    bool isLegal=true; // 标记是否合法：每个点仅赋值一次
    vector<int> out; // 层次遍历输出存储
    queue<Node*> q; // 遍历队列
    if (root != NULL) q.push(root); // 初始化
    while (!q.empty() && isLegal) {
        Node* node = q.front(); q.pop();
        if (node->assignCnt != 1) isLegal = false; // 非法：赋值0或多次
        else {
            out.push_back(node->val);
            if (node->l != NULL) q.push(node->l); // 非空压入左右子树
            if (node->r != NULL) q.push(node->r);
        }
    }
    if (isLegal) { // 合法输出
        for (int i=0; i < out.size(); i ++) 
            printf("%d%s", out[i], i == out.size()-1 ? "\n" : " ");
    }
    else printf("not complete\n");
}
int main() {
    string s;
    while (cin >>s) {
        if (s == "()") {
            layerTra(btree);
            btree=NULL; // 此处可改为递归释放内存，偷个懒，不写了
        }
        else {
            if (btree == NULL) btree = new Node; // 根必须先创建，否则是空值则无法连接节点
            insertNode(s, btree);
        }
    }
    return 0;
}
```

## 例题6-8 UVA548 Tree

### 题目大意

给定二叉树的中序和后序遍历序列，求该二叉树中根到叶子的路径和最小者，若存在多个解，则选择叶子权值最小者（叶子权值不重复）

### 思路分析

关键在于中序和后序建树，后序遍历序列的最后一个元素来确定根（前序的话是第一个元素确定更），中序序列来划分左右子树，如此递归建立树

对于路径和求解，建树完成后对树进行dfs

### AC代码（C++11，中后序建树）

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node {
    int v; // 值
    Node *l=NULL, *r=NULL; // 左右子树
};
vector<int> in, post; // 中序，后序存储
int minSum=0x3fffff, ans=-1; // 路径最小和，答案
Node* createTree(int i1, int j1, int i2, int j2) { // 建树-- in:[i1,j1) post:[i2,j2)
    if (i1 >= j1 || i2 >= j2) return NULL; // 空树
    Node* root = new Node;
    root->v = post[j2-1]; // 后序结尾为个
    int j = find(in.begin()+i1, in.begin()+j1, post[j2-1]) - in.begin(); // 在in中查找
    root->l = createTree(i1, j, i2, i2+(j-i1)); // 左子树建立
    root->r = createTree(j+1, j1, i2+(j-i1), j2-1); // 右子树建立
    return root;
}
void dfs(Node* root, int sum) { // 计算到每个叶子的路径和并记录最小者
    if (root->l == NULL && root->r == NULL) { // 叶子
        sum += root->v;
        if (sum < minSum || (sum == minSum && ans > root->v)) { // 总和最小；若相同去叶子值最小者
            minSum = sum;
            ans = root->v;
        }
        return;
    }
    if (root->l != NULL) dfs(root->l, root->v+sum); // 非空，则访问左子树
    if (root->r != NULL) dfs(root->r, root->v+sum); // 非空，则访问右子树
}
int main() {
    string s1, s2, st;
    while (getline(cin, s1) && getline(cin, s2)) {
        in.clear(); post.clear(); // 初始化
        stringstream input1(s1), input2(s2);
        while (input1 >>st) in.push_back(stoi(st)); // 中序存储
        while (input2 >>st) post.push_back(stoi(st)); // 后续存储
        Node* btree = createTree(0, in.size(), 0, post.size()); // 建树
        minSum=0x3fffff; dfs(btree, 0); // 遍历计算
        printf("%d\n", ans);
    }
    return 0;
}
```

## 例题6-9 UVA839 Not so Mobile

### 题目大意

给出每个支点的左右物体重量和到支点的距离，`wl,dl,wr,dr`分别表示左边物体重量和到左边的距离，右边物体重量和到右边的距离，当`wl*dl==wr*dr`成立时，说明杠杆平衡。忽略所有绳子和杠杆重量。

### 思路分析

有两种思路

+ 朴素：直接根据输入先序建树，接着后序遍历判断是否平衡
+ 优化：在**先序建树**过程中插入**后序判断**是否平衡（隐式建树，即为正真的建立一个二叉树）

同时，本题的输入略为麻烦，若直接当成字符串按行处理十分复杂，本题给出的输入又有些特殊，是**先序遍历的顺序输入，因此利用递归建树**方式，自动会控制读入的输入行数，因此可无需自己控制输入

### 注意点

+ 二叉树是递归定义的数据结构，因此测试也可采用递归测试，坑点少

### AC代码（C++11）

#### 优化代码（19行）

```cpp
#include<bits/stdc++.h>
using namespace std;
int T, W;
bool isEqu(int& w) { // 先序读入（隐式建树）；后序判断是否平衡
    int wl, dl, wr, dr;
    scanf("%d %d %d %d", &wl, &dl, &wr, &dr);
    bool b1=true, b2=true; // 判断左右子树是否平衡
    if (wl == 0) b1 = isEqu(wl); // 左子树递归判断
    if (wr == 0) b2 = isEqu(wr); // 右子树递归判断
    w = wl + wr; // 重量为引用，累加影响上一层结果
    return b1 && b2 && (wl * dl == wr * dr); // 左右子树和当前节点均平衡
}
int main() {
    scanf("%d", &T);
    for (int i = 0; i < T; i ++) {
        printf("%s%s", isEqu(W) ? "YES":"NO", i == T-1 ? "\n":"\n\n");
    }
    return 0;
}
```

#### 朴素代码（45行代码）

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node {
    int wl, wr, dl, dr;
    Node *l=NULL, *r=NULL;
};
string s;
int T;
bool readInput(int& wl, int& dl, int& wr, int& dr) { // 读取输入
    if (getline(cin, s) && !s.empty()) {
        stringstream input(s);
        input >>wl >>dl >>wr >>dr;
        return true; // 成功
    }
    else return false; // 失败
}
Node* createTree() { // 递归建树（先序）
    Node* root = NULL;
    int wl, dl, wr, dr;
    if (readInput(wl, dl, wr, dr)) { // 读入成功
        root = new Node;
        root->wl = wl; root->wr = wr;
        root->dl = dl; root->dr = dr;
        if (wl == 0) root->l = createTree();
        if (wr == 0) root->r = createTree(); 
    }
    return root;
}
int dfs(Node* root) { // 后序遍历并判断是否平衡
    if (root == NULL) return -1; // 空树
    if (root->l != NULL) root->wl = dfs(root->l); // 左子树
    if (root->r != NULL) root->wr = dfs(root->r); // 右子树
    if (root->wl == -1 || root->wr == -1) return -1; // 非法，剪枝
    if (root->wl * root->dl == root->wr*root->dr) return root->wl+root->wr; // 平衡，返回左右重量和
    else return -1; // 非法标志
}
int main() {
    scanf("%d  ", &T); // 两个空格可吸收换行
    for (int i = 0; i < T; i ++) {
        Node* bt = createTree();
        printf("%s%s\n", dfs(bt) != -1 ? "YES" : "NO", i != T-1 ? "\n" : "");
        if (i != T-1) getchar(); // 空行吸收
    }
    return 0;
}
```

## 例题6-10 UVA699 The Falling Leaves

### 题目大意

以树根节点为中心，画一根垂直线（可看成y轴），因此树根坐标为0，它的左子树根为-1，右子树根为+1，依次类推，即往左走-1，往右走+1，现在将坐标相同的点看成一叠，从左到右输出他们的权值和。

### 思路分析

和**例题6-9**有些类似，直观思路是想通过输入先序建树，然后再次dfs计算每叠的总和。

那么自然可利用同样的优化手段，即无需真正的建立一个二叉树，而是**隐式建立二叉树**（只遍历，不留下任何痕迹：），同时定义`map<int,int> cnt;`来统计每叠对应的权值总和，因为`map`对按键值从小到大排序，免去了输出时排序的繁琐，这也是为什么令左子树-1，右子树+1的缘故。

注意利用输入数据的先序特点，可使用递归建树，避免复杂的输入处理

### 注意点

+ 每组测试用例输出均需跟上一个空行！！！

### AC代码（C++11，先序隐式建树，map）

```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int> cnt; //  位置->个数；统计每叠对应权值总和
void createTree(int pos=0) { // 先序隐式建树，同时累加每个位置的值
    int v; scanf("%d", &v);
    if (v != -1) {
        cnt[pos] += v; // 累加值
        createTree(pos-1); // 左子树
        createTree(pos+1); // 右子树
    }
}
int main() {
    for (int i = 1; ; i ++) {
        cnt.clear(); createTree(0); // 初始化，隐式建树求值
        if (cnt.empty()) break; // 读到最后一个-1，结束
        printf("Case %d:\n", i);
        for (auto p : cnt) { // map按照key的字典序升序排列
            printf("%d%s", p.second, p.first == cnt.rbegin()->first ? "\n" : " ");
        }
        puts(""); // 每个测试用例后均有空行
    }
    return 0;
}
```

## 例题6-11 UVA297 Quadtrees

### 题目大意

一个四叉树有三类节点，即父结点（P），黑色叶子（f），白色叶子（e）

现给出两个四叉树，求合并后黑色像素个数。

### 思路分析

输入为四叉树的先序序列，因此先序递归建树很容易，但关键在于如何合并两棵四叉树，计算黑色个数。

+ 尝试1：想**同步层次/先序遍历**两个四叉树，然后统计黑色个数，可惜两个树结构不完全一致，实现有些困难
+ 尝试2：将**四叉树转换为原图片的二维矩阵**，然后用标记的方式来统计黑色个数，正解

> 尝试2的思路很有启发性，对于复杂的树/图结构，可以转换为规则的一维/二维数组，便于做各种计算

因此可以不用真正建立四叉树（类似UVA839，UVA699，隐式建树），在转换为原图二维矩阵时，可借用哈希的思想（空间换时间），遇见黑色就将整个正方形中的小格子全标记为黑色，因此可以直接统计黑色个数。

### 注意点

+ 注意初始化数组为0
+ 注意使用引用变量
+ 可用技巧：四叉树转换为二维矩阵，隐式建树，空间换时间

### AC代码（C++11，四叉树转二维矩阵，隐式建树，空间换时间）

```cpp
#include<bits/stdc++.h>
using namespace std;
int T, cnt, img[1025][1025]={0}, idx;
// 根据s[idx]绘制左上角为(r,c)，边长为w的正方形区域
void draw(string s, int& idx, int r, int c, int w) {
    if (idx >= s.size()) return;
    idx ++; // 先后移,注意引用
    if (s[idx-1] == 'p') { // 父结点，绘制4个子方格
        draw(s, idx, r, c+w/2, w/2);     // 1
        draw(s, idx, r, c, w/2);         // 2
        draw(s, idx, r+w/2, c, w/2);     // 3
        draw(s, idx, r+w/2, c+w/2, w/2); // 4
    }
    else if (s[idx-1] == 'f') { // 黑色才处理，白色默认0，不计数
        for (int i = r; i < r+w; i ++)  // 按最小方块标记上色
            for (int j = c; j < c+w; j ++) 
                if (img[i][j] == 0) {cnt++; img[i][j] = 1;} // 统计黑色个数，记得加标记
    }
}
int main() {
    scanf("%d", &T);
    string s1, s2;
    while (T --) {
        cin >>s1 >>s2;
        cnt=0; fill(img[0], img[0]+1025*1025, 0); // 初始化 
        draw(s1, idx=0, 0, 0, 32); // 1024=32*32个格子
        draw(s2, idx=0, 0, 0, 32); // 注意初始化idx=0
        printf("There are %d black pixels.\n", cnt);
    }
    return 0;
}
```

## 例题6-12 UVA572 Oil Deposits

### 题目大意

给定m\*n的矩形方格，`*和@`分别表示没油和有油，求矩形方格中连通的油块个数（**同一行，列，左右斜线上相邻均称作连通**）

### 思路分析

用字符串二维数组grid存储方格，进行dfs遍历，在遍历中，将同一块中的格子用`*`标记，以免后续重复访问。

可定义8个方向向量，简化代码

### 注意点

+ 若用字符形式依次读入注意处理换行；若用string或字符串则无需考虑

### AC代码（C++11，dfs连通块）

```cpp
#include<bits/stdc++.h>
using namespace std;
int m, n, dict[8][2]={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}}; // 8个方向
char grid[101][101]; // 方格
void dfs(int x, int y) {
    grid[x][y] = '*'; // 标记
    int xx, yy;
    for (int i = 0; i < 8; i ++) { // 8个方向
        xx = x + dict[i][0]; yy = y + dict[i][1];
        if (xx >= 0 && xx < m && yy >= 0 && yy < n && grid[xx][yy] == '@') dfs (xx, yy); // 位置合法&&有油
    }
}
int main() {
    while (scanf("%d %d", &m, &n) == 2 && m != 0) {
        getchar(); // 吸收空行
        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j ++) scanf("%c", &grid[i][j]);
            getchar(); // 吸收空行
        }
        int ans = 0; // 存储结果
        for (int i = 0; i < m; i ++) { // 遍历所有格子
            for (int j = 0; j < n; j ++) {
                if (grid[i][j] == '@') { // 发现油格
                    ans ++; // 数量增加
                    dfs(i, j); // 找连通块
                }
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

## 例题6-13 UVA1103 Ancient Messages

### 题目大意

给定6种象形字符及其对于的标记字母，现用16进制字符表示一张图像，以字典序输出图像中的所有象形字符。有以下简化约定：

+ 字符仅包括给定的6种
+ 每个图像至少包含一个象形字符
+ 每个黑色像素均属于一个象形字符
+ 字符间相互独立，即不相交，不包含
+ 处于**对角位置**的像素也算相邻
+ 图像可以**拉伸**

### 思路分析

> 一道十分有趣的题目，值得琢磨。通过以下三个核心问题来讨论解决思路

```cpp
问题1：如何分辨不同象形字符？
回答1：图像内部的白洞个数
```

这里需要一点想象力和观察力，既然图像可以拉伸变换，因此必须要找到一个不变的特征量，仔细观察所给出的6个图像，可以发现每个图像内部所包含的白洞个数依次为：`1,3,5,4,0,2`。正好6个数无重复值，因此可以用图像的内部的白洞个数来辨别字符

```cpp
问题2：怎么判断白色块属于哪个黑色连通块内部？
回答2：单个拷贝
```

若一张图中仅有一个黑色连通块，那么它的白色连通块可轻易计算出来，但存在多个黑色连通块时，就无法直接判定每个黑色连通块内部的白色块个数了。因此，假设原图存于img1，遍历其中一个黑色连通块的同时，拷贝到img2，此时img2中只包含一个黑色连通块，即可轻易计数

```cpp
注意：直接拷贝的方式存在一个bug
解决：给拷贝的img2四周增加一个白色像素框（上下左右均多加一个）
```

当图中仅含一个黑色连通块时，**令黑色像素点与边界围成白色块**，会导致白色块增加。因此，可在img2四周增加一圈白框，连通外围白色块，避免以上bug

### 算法设计

先将16进制字符串转换为4位的2进制字符串，可用`bitset`快速实现

定义`string img[205], img2[205];` 分别表示原图像，加一圈白边的图像

枚举img中的黑色连通块，对于每个黑色连通块，dfs过程中同步拷贝到img2，拷贝完毕后，dfs计算img2中的白色块个数

+ 对于8个方向可用方向向量或一个二重循环处理
+ 映射转换关系可用map或哈希表实现，简化代码

### AC代码（C++11，思维题，dfs）

```cpp
#include<bits/stdc++.h>
using namespace std;
int H, W, num=0;
string img[205], img2[205], s; // 原图像，加一轮白边的图像
map<char, string> mp; // 16进制字符->4位的2进制字符串
char word[6] = {'W', 'A', 'K', 'J', 'S', 'D'}; // 象形字内部对应的白色块个数
void trans() { // 一位16进制字符[0,f]转为4位的二进制字符串
    char c[] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
    for (int i = 0; i < 16; i ++) {
        bitset<4> bt(i); // 10->二进制数值->二进制字符串
        mp[c[i]] = bt.to_string();
    }
}
void dfs(int x, int y, char tag) { // tag='0'：遍历img的一个黑色连通块，并拷贝到img2；tag='0'：计算img2的白色连通块个数
    if (tag == '0') img[x][y] = '0';
    if (tag == '0') img2[x+1][y+1] = '1'; // 白色边框
    else img2[x][y] = '1';
    int xx, yy, h, w;
    for (int i = -1; i <= 1; i ++) { // 8个方向
        for (int j = -1; j <= 1; j ++) {
            if (i == 0 && j == 0) continue; // 不写也行，自身已经被赋值为1了
            xx = x + i; yy = y + j;
            h = (tag == '1') ? H+2 : H; w = (tag == '1') ? 4*W+2 : 4*W; // 边界控制
            if (xx >= 0 && xx < h && yy >= 0 && yy < w) {
                if (tag == '0' && img[xx][yy] == '1' || tag == '1' && img2[xx][yy] == '0') dfs(xx, yy, tag);
            }
        }
    }
}
int main() {
    trans(); // 16转二进制字符串初始化 
    while (cin >>H >>W && (H != 0 && W != 0)) {
        for (int i = 0; i < H; i ++) {
            cin >>s; img[i].clear();
            for (int j = 0; j < s.size(); j ++) img[i].append(mp[s[j]]); // 转为2进制
        }
        vector<char> res; // 保存结果
        for (int i = 0; i < H; i ++) {
            for (int j = 0; j < 4*W; j ++) {
                if (img[i][j] == '1') { // 发现一个黑色块
                    for (int k=0; k < H+2; k ++) img2[k] = string(4*W+2, '0'); // 初始化
                    dfs(i, j, '0'); // 拷贝连通块
                    int cnt=0; // 统计白色块个数
                    for (int i2 = 0; i2 < H+2; i2 ++) { // img2计算白色洞个数
                        for (int j2 = 0; j2 < 4*W+2; j2 ++) { // 注意长度和宽度
                            if (img2[i2][j2] == '0') {cnt++; dfs(i2, j2, '1');}
                        }
                    }
                    res.push_back(word[cnt-1]); // 存储对应象形字符结果
                }
            } 
        }
        sort(res.begin(), res.end()); // 字典序排列
        printf("Case %d: ", ++num);
        for (auto c : res) printf("%c", c);
        puts("");
    }
    return 0;
}
```



## 例题6-14 UVA816 Abbott's Revenge

+ 点可以重复遍历，但每个点的对于的方向仅遍历一次vis[x\][y\][d]
+ 路径记录



| 坐标变换 | 前进方向 \ 相对转向 --> | L    | F    | R    |
| -------- | ----------------------- | ---- | ---- | ---- |
| (-1,0)   | N                       | W    | N    | E    |
| (+1,0)   | S                       | E    | S    | W    |
| (0,-1)   | W                       | S    | W    | N    |
| (0,+1)   | E                       | N    | E    | S    |

## 例题6-15 UVA10305 Ordering Tasks

### 题目大意

给出有向无环图，输出拓扑排序（若有多个则任意输出一个）

### 思路分析

定义邻接表`adj`存储有向无环图，定义`indegree`记录每个点的入度

```cpp
vector<vector<int> > adj(n+1); // 邻接表
vector<int> indegree(n+1), ans; // 入度表，从1开始；存储结果
```

定义队列`q`模拟拓扑排序过程，具体过程如下：

+ 初始化：将入度为0的顶点加入队列q，并置入度indegree为-1，表示已访问
+ 若队列非空，队首u出队（出队即可输出），将u能到达的下一个顶点的入度减1，再将入度为0的顶点入队

### 注意点

+ m可能等于0，n不为0，如`n=5,m=0`，未考虑会`WA`

### AC代码（C++11，拓扑排序）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, a, b;
void update(vector<int>& indegree, queue<int>& q) { // 更新队列
    for (int i = 1; i <= n; i ++) {
        if (indegree[i] == 0) { // 入度为0
            q.push(i); // 入队
            indegree[i] = -1; // 标记为已访问
        }
    }
}
int main() {
    while (cin >>n >>m && (n != 0 || m != 0)) { // 仅m=0是合法的，如n=5,m=0
        vector<vector<int> > adj(n+1); // 邻接矩阵
        vector<int> indegree(n+1), ans; // 入度表，从1开始；存储结果
        while (m --) {
            cin >>a >>b;
            adj[a].push_back(b);
            indegree[b] ++; // 入度累加
        }
        queue<int> q; update(indegree, q); // 初始化
        while (!q.empty()) {
            int u = q.front(); q.pop(); ans.push_back(u);
            for (int v : adj[u]) indegree[v] --; // 更新入度表
            update(indegree, q); // 更新队列
        }
        for (int i = 0; i < ans.size(); i ++) printf("%d%s", ans[i], i == ans.size()-1 ? "\n" : " ");
    }
    return 0;
}
```

## 例题6-16 UVA10129 Play on Words

### 题目大意

能否将n个单词顺序连接，其中每个单词的最后一个字母等于它后序单词的首字母（类似词语接龙）。其中单词可以重复。

### 思路分析

如果将26个小写字母作为图的顶点，每个单词作为边（比如`one作为定点o和e的边`），那么问题等价于是否存在欧拉回路或通路，在保证**图是连通（有向图则不考虑方向）**的情况下，有向图和无向图对应的欧拉路判定条件见下表：

|          | 无向图                                  | 有向图                                                       |
| -------- | --------------------------------------- | ------------------------------------------------------------ |
| 欧拉回路 | 所有点均为偶度顶点（顶点度数为偶数）    | 所有点出度=入度（入度=箭头射入个数）                         |
| 欧拉通路 | 最多仅2个点为奇度顶点（顶点度数为奇数） | 最多两个点出度!=入度；其中一个出度比入度大1；另一个入度比出度大1 |

因此解决思路如下：

+ 连通图判定：并查集或者dfs均可
+ 顶点出入度：用`degree[i]`记录每个点的出入度结果，出则-1，入则+1，结果为0表示出入度相同

### 注意点

+ 不要直接用每个单词作为结点来构建图，这样会超时

+ 考虑仅1个单词的情况
+ 用并查集压缩路径时，注意最后还要再次遍历每个点，避免有些点的父结点为更新

### AC代码（C++11，欧拉路径）

```cpp
#include<bits/stdc++.h>
using namespace std;
int T, n;
int findFather(int a, vector<int>& father) { // 并查集找父结点
    return father[a] = (father[a] == a) ? a : findFather(father[a], father);
}
int main() {
    scanf("%d", &T);
    string s;
    while (T --) {
        scanf("%d", &n);
        vector<int> degree(26,0), father(26); // 26个字母对应的入度表，父结点
        for (int i = 0; i < 26; i ++) father[i] = i; // 初始化并查集父结点
        set<char> _set; // 存储出现的字符个数（去重）
        for (int i = 0; i < n; i ++) {
            cin >>s; 
            _set.insert(s[0]); _set.insert(s.back()); // 头尾插入集合
            degree[s[0]-'a'] --; degree[s.back()-'a'] ++; // 出度和入度计算
            father[s[0]-'a'] = findFather(s.back()-'a', father); // 并查集计算
        }
        int even=0, sp=-1, ep=-1; // 偶度顶点
        for (int i=0; i < 26; i ++) {
            if (degree[i] == 0) even ++;
            else if (degree[i] == 1) sp = 1; // 奇度顶点，且出度-入度=1
            else if (degree[i] == -1) ep = 1; // 奇度顶点，且出度-入度=-1
        }
        for (int i=0; i < 26; i ++) father[i] = findFather(i, father); // 最后来一遍，防止有些顶点没被更新
        int num=0;
        for (int i=0; i < 26; i ++) if (father[i] == i) num ++; // 不同的集合个数
        if ((even == 26-2 && (sp==1&&ep==1) || even == 26) && num == 1+26-_set.size()) printf("Ordering is possible.\n");
        else printf("The door cannot be opened.\n");
    }
    return 0;
}
```

## 例题6-17 UVA10562 Undraw the Trees

### 题目大意

> 本题理解题目很关键

给定ascii字符表示的多叉树，输出指定的括号表达形式。

其中存在共用孩子结点情况和重复结点名情况，如下图所示

+ **共用孩子结点**：B的孩子是C和E，D的孩子也是C和E
+ **重复结点名**：第一个结点A和最后一个同名，但输出时照输不误

```cpp
A
|
--
BD
||
--
CE
|
A
```

### 思路分析

最直接的思路是**解析字符串，构造多叉树，先序遍历输出**，从多叉树到输出转换很容易，但是解析字符串较为繁琐，因此问自己一个问题：**一定要构建多叉树吗？**

先看直接思路，若是解析字符串，必须通过`|--`等字符间的位置关系来确定孩子和父亲关系，但转念一想，我能够解析这些关系，说明我已经能够得到字符之间的位置关系了，那直接把整棵树存在一个二维数组中，不就可以随时获取字符间位置关系了吗？

通过以上分析，发现可以省略实际建树的过程，在分析字符间关系时顺便输出结果，代码也极为简短

之后会给出两种思路对于的代码，可对比分析优劣

### 注意点

+ 注意访问数组的元素时先判断是否越界，因为本题输入中每一行宽度不一定相同

+ `scanf和fgets/getline`混用时，注意吸收多余换行
+ 空树特判

### AC代码（C++11）

#### 二维数组递归输出（29行）

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
vector<string> buf; // 存储输入的树
void dfs(int r, int c) { // 递归打印以buf(r,c)为根的子树
    printf("%c", buf[r][c]);
    if (r < buf.size()-1 && buf[r+1][c] == '|') { // 有孩子
        putchar('('); int l=c;
        while (buf[r+2][l] == '-') l--; // 查找--的左边界
        for (int i=l+1; i < buf[r+2].size() && buf[r+2][i] == '-'; i ++) {
            if (i < buf[r+3].size() && buf[r+3][i] != ' ') dfs(r+3, i); // 注意r+3的有效范围判断
        }
        putchar(')');
    }
    else printf("()");
}
int main() {
    scanf("%d", &T); getchar(); // 吸收多余换行
    string s;
    while (T --) {
        buf.clear();
        while (getline(cin, s) && s != "#") buf.push_back(s); // 以数组存储树
        putchar('(');
        for (int i=0; !buf.empty() && i < buf[0].size(); i ++) 
            if (buf[0][i] != ' ') {dfs(0,i); break;} // 找到根
        puts(")");
    }
    return 0;
}
```

#### 字符串解析建树（51行）

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
void dfs(map<int,vector<int> >&tree, vector<char>& dict, int root=0) { // 根据多叉树递归打印
    if (dict.size() > root) printf("%c", dict[root]);
    if (!tree[root].empty()) {
        printf("(");
        for (auto t : tree[root]) dfs(tree, dict, t);
        printf(")");
    }
    else printf("()");
}
int main() {
    scanf("%d", &T); getchar(); // 吸收多余换行
    string s[4]; // 4行：根，|,-,孩子
    while (T --) {
        map<int,vector<int> > tree; // 多叉树
        vector<char> dict; // 结点字符字典（给每个字符进行编号，处理重复字符）
        map<int,int> id; // 每个位置->对应字符的id
        getline(cin, s[0]);
        if (s[0][0] == '#') {printf("()\n"); continue;} // 空树
        auto p = find_if(s[0].begin(), s[0].end(), [](char& ch){return ch != ' ';});
        id[p - s[0].begin()] = dict.size(); dict.push_back(*p);
        while (getline(cin, s[1]) && s[1][0] != '#') {
            getline(cin, s[2]); getline(cin, s[3]); 
            vector<int> a[3]; // a[1]表示|所在位置，a[2]表示每段-的起止位置
            for (int i=0; i < s[1].size(); i ++) if (s[1][i] == '|') a[1].push_back(i); // |的位置
            int flag=0;
            for (int i=0; i < s[2].size(); i ++) { // -分割区间：[起始,结束)
                if (flag == 0 && s[2][i] == '-') a[2].push_back(i), flag=1; // 起点
                else if (flag == 1 && s[2][i] == ' ') a[2].push_back(i), flag=0; // 终点
            }
            if (a[2].size() % 2 != 0) a[2].push_back(s[2].size()); // 最后一段-
            map<int,int> tid; // 临时存储
            for (int i=0; i < s[3].size(); i ++) { // 孩子处理
                if (s[3][i] != ' ') {
                    for (int j=0; j < a[2].size(); j += 2) // 查询在哪一段
                        if (a[2][j] <= i && i < a[2][j+1]) {
                            tid[i] = dict.size(); dict.push_back(s[3][i]);
                            for (int k=0; k < a[1].size(); k ++) { // 查询符合区间的父结点
                                if (a[2][j] <= a[1][k] && a[1][k] < a[2][j+1]) tree[id[a[1][k]]].push_back(dict.size()-1);
                            }
                        }
                }
            }
            id = tid; s[0] = s[3]; // 更新
        }
        putchar('('); dfs(tree, dict, 0); puts(")");
    }
    return 0;
}
```

## 例题6-18 UVA12171 Sculpture

### 题目大意

给定笛卡尔坐标系上的长方体左下角坐标和对应边长，长方体间存在相离，相切，相交等各种关系，求总体的体积和表面积，对于完全被长方体包围的空间计算器体积而忽略面积。

### 思路分析

> 极好的一道题目，综合性强，思维量大，技巧性强，编码量大
>
> 强烈建议完全弄懂分析思路，写代码是水到渠成的事

```cpp
问题1：完全没有思路怎么办？
答案1：构造三维网格，离散化/微元切割，空间换时间
```

一眼看去，毫无头绪，难点关键在于**长方体间复杂关系**的处理，那么可假想有一个足够大的**三维网格**，每个格子体积为单位1，输入长方体时填充相应网格，最后直接统计网格即可，这样顺利的避免了长方体复杂的关系处理。这个思路运用了两个**设计思想**：

+ **离散化/微元切割**：将**复杂的物体**用**规则的网格**替代计算，将所有运算转换为加法（类似于微积分思想，取微元，近似为规则的长方形或三角形处理）

+ **空间换时间**：三维网格足够大，每个格子有二元状态，即**属于长方体或不属于长方体**，每个格子内部状态等效，有效简化了逻辑的复杂度

```cpp
问题2：网格使用的空间超过限制怎么办？
答案2：离散化技巧
```

看起来很美好，但是本题坐标最大值为1000，意味着最大空间需10^9，显然需要进行空间优化，可以考虑**离散化**技巧（[类似UVA221](https://blog.csdn.net/qq_40738840/article/details/104217617)，它是二维离散化），这里是三维，本质是一样的，将连续无限的状态转换为离散有限状态。本题最多有50个点，因此最多有100个位置，这里空间仅需10^6，完全满足。

```cpp
问题3：怎么计算铜块体积和面积？
答案3：整体局部做差法，逆向思维，连通块floodfill
```

由于铜块内部关系错综复杂，我们可以转为计算空气的体积（这里需要一点想象力），再用网格总体积减去空气体积，即可得到铜块体积；而面积就是空气的内表面积。关于体积面积可用**连通块算法**计算（英文名floodfill：意为像洪水填充物体，有孔则入；实现用bfs/dfs）

```cpp
问题4：计算空气体积和面积时，空气可能存在多个连通块？
答案4：补边法（在三维网格外围增加一层空气网格）
```

类似于[UVA1103](https://blog.csdn.net/qq_40738840/article/details/104333616)，在外围补一层空白网格，将所有空气连通块打通，成为一块（类似打通任督二脉，九九归一）

顺便总结下**离散技巧（类似等效法，划分出一个内部状态均等效的单元，从而用一个点代替一部分）**使用时问题的特征，对应解决策略和实现技巧（只看是理解不了的，建议做题）

| 问题特征 | 解决策略                               | 编码实现                                 |
| -------- | -------------------------------------- | ---------------------------------------- |
| 复杂关系 | 微元降解，每个单元内部任意一点状态等价 | 存储原有数据，计算目标结果               |
| 无限状态 | 离散化，单元的数量降为有限可数         | 一般是排序，存储离散化数据，用于算法计算 |

### 算法设计

本题算法设计也极具借鉴意义，先看数据结构（必须理解思路分析中的离散法技巧）

```cpp
const int maxn=55, maxp=1001; // 长方体个数最大值，坐标最大值
int color[maxn*2][maxn*2][maxn*2]; // 标记长方体是空气还是铜盘，bfs使用；0空气，1铜盘，2空气已访问
int x0[maxn], x1[maxn], y0[maxn], y1[maxn], z0[maxn], z1[maxn]; // 原始数据，每个长方体的xyz边长起止位置
int xs[2*maxn], ys[2*maxn], zs[2*maxn]; // 离散化坐标：xs存储x0和x1中所有去重升序排列后的坐标
int nx, ny, nz; // 记录xs,ys,zs的长度
int dirt[6][3]={{+1,0,0},{-1,0,0}, {0,+1,0},{0,-1,0}, {0,0,+1},{0,0,-1}}; // 沿着x,y,z轴的6个方向的方向向量
```

其中最为重要的莫过于存储离散化坐标的`xs,ys,zs`和标记离散化后的网格的状态的三维数组`color`（**注意此时用长方体的左下角坐标代表整个长方体，即利用离散化的等效原则：长方体内任意一点状态一致**）。有了这些就足够完成floodfill了，那么**为何要记录原始数据**？因为题目要求计算出最终的体积和面积，因此需要带入真正的数据。那么**怎么保证访问原始数据的速度**？因为离散化后的坐标均为升序序列，可用二分查找，时间接近常数。

```cpp
int getId(int *a, int n, int val) { // 获取val在数组a中的下标
    return lower_bound(a, a+n, val) - a; // 复杂度logn，接近常数查找
}
```

同时为了便于floodfill算法的实现，封装`Cell`结构体，内含`x,y,z`成员表示离散化后的网格坐标，他们实际上是索引，例如`xs[x+1]-xs[x]`表示左下角为`(x,y,z)`的离散化后的长方体的x方向边长；同时也封装了常用的构造函数，面积和体积计算函数。对于面积计算有些技巧

在floodfill时遇到铜块则需要计算面积，那么由两个问题需回答：

```cpp
问题5：空气块A紧邻有铜块B，该用谁来计算面积？
回答5：空气块A
```

若用铜块B计算，可能导致重复计算。因为一个铜块可能与多个空气块接触，floodfill过程中会遍历每一个空气块，若每次均用铜块B计算，那么会导致B的部分面积重复计算，因此选用空气块A

```cpp
问题6：该计算空气块A的哪一个面？
答案6：与铜块相邻的面（与移动方向垂直的面）
```

上面定义了方块移动的6个方向，若A和B沿x轴相邻，则计算y*z的面积，依次类推

```cpp
问题7：floodfill用dfs还是bfs实现？
答案7：bfs（dfs在状态多时容易爆栈）
```

剩余的就是老老实实，仔仔细细的写代码和调试了

### 注意点

+ 因为给三维网格增加一层外围空气块，需注意在离散化时处理该问题
+ 变量`x0,y0,y1.....`与头文件`math.h`中的变量定义冲突，建议不用万能头文件或者更换变量名
+ 注意计算内表面积时算的是空气块部分的接触面积，否则会重复计算
+ 用`unique和lower_bound`函数前必须保证序列有序，二者均返回迭代器/指针
+ 结构体和类很像，可以利用它封装函数，简化代码，提高可读性

+ 建议理解透彻在动手写代码

### AC代码（C++11，离散化，floodfill/bfs）

```cpp
// #include<bits/stdc++.h> // 不要用万能头文件,math.h中的x0,x1...会产生冲突
#include <cstdio> // scanf,printf
#include <algorithm> // sort,lower_bound
#include <queue> // queue
#include <cstring> // memset()
using namespace std; // 默认命名空间

const int maxn=55, maxp=1001; // 长方体个数最大值，坐标最大值
int color[maxn*2][maxn*2][maxn*2]; // 标记长方体是空气还是铜盘，bfs使用；0空气，1铜盘，2空气已访问
int x0[maxn], x1[maxn], y0[maxn], y1[maxn], z0[maxn], z1[maxn]; // 原始数据，每个长方体的xyz边长起止位置
int xs[2*maxn], ys[2*maxn], zs[2*maxn]; // 离散化坐标：xs存储x0和x1中所有去重升序排列后的坐标
int nx, ny, nz; // 记录xs,ys,zs的长度
int dirt[6][3]={{+1,0,0},{-1,0,0}, {0,+1,0},{0,-1,0}, {0,0,+1},{0,0,-1}}; // 沿着x,y,z轴的6个方向
int getId(int *a, int n, int val) { // 获取val在数组a中的下标
    return lower_bound(a, a+n, val) - a; // 复杂度logn，接近常数查找
}
struct Cell { // 存储逻辑上的长方体
    int x, y, z; // 用来bfs的坐标，表示长方体左下角
    Cell (int _x, int _y, int _z) : x(_x), y(_y), z(_z) {} // 构造函数
    bool isValid() {return (0 <= x && x < nx-1) && (0 <= y && y < ny-1) && (0 <= z && z < nz-1);} // 判断位置是否合法
    Cell getNeighbor(int dir) {return Cell(x+dirt[dir][0], y+dirt[dir][1], z+dirt[dir][2]);} // 返回dir方向的邻居
    int getVolume() { // 计算体积
        return (xs[x+1]-xs[x]) * (ys[y+1]-ys[y]) * (zs[z+1]-zs[z]); // 长*宽*高
    }
    int getArea(int dir) { // 根据方向获取内表面积
        if (dirt[dir][0] != 0) return (ys[y+1] - ys[y]) * (zs[z+1] - zs[z]); // 空气从x轴接触铜块，面积为y*z
        else if (dirt[dir][1] != 0) return (xs[x+1] - xs[x]) * (zs[z+1] - zs[z]); // 空气从y轴接触铜块
        else if (dirt[dir][2] != 0) return (xs[x+1] - xs[x]) * (ys[y+1] - ys[y]); // 空气从z轴接触铜块
        return -1; // 表示出错
    }
    bool isCopper() {return color[x][y][z] == 1;} // 判断是否为铜块
    bool isVisited() {return color[x][y][z] == 2;} // 若为空气，判断是否被访问
    void setVisited() {color[x][y][z] = 2;} // 设置为已访问
};
void discretize(int *a, int& n) { // 升序排列a，并去重；n为a的逻辑长度，注意引用
    sort(a, a+n); // 先排序
    n = unique(a, a+n) - a; // unique返回去重后的逻辑列表末尾指针
}
void bfs(int& v, int& m) { // 计算体积和表面积
    queue<Cell> q;
    q.push(Cell(0,0,0)); color[0][0][0] = 2; // 初始化，从加入的外围白边开始
    while (!q.empty()) {
        Cell cell = q.front(); q.pop();
        v += cell.getVolume(); // 累加空气体积
        for (int i=0; i < 6; i ++) { // 6个方向
            Cell neb = cell.getNeighbor(i); // 获取邻居
            if (neb.isValid()) { // 邻居有效
                // if (neb.isCopper()) m += neb.getArea(i); // 是铜块则累加从i方向接触的表面积
                if (neb.isCopper()) m += cell.getArea(i); // 是铜块则累加从i方向接触的表面积，若用neb计算面积，会导致重复计算
                else if (!neb.isVisited()) { // 未访问的空气块
                    neb.setVisited(); // 设为已访问
                    q.push(neb); // 加入队列
                }
            }
        }
    }
    v = (maxp*maxp*maxp) - v; // 铜块体积=总体积-空气体积
}
int main() {
    int T, n, lx, ly, lz; scanf("%d", &T);
    while (T --) {
        scanf("%d", &n);
        xs[0] = 0, ys[0] = 0, zs[0] = 0; // 增加一层外围起点
        xs[1] = maxp, ys[1] = maxp, zs[1] = maxp; // 外围终点
        nx = ny = nz = 2; // 当前长度
        for (int i=0; i < n; i ++) {
            scanf("%d %d %d %d %d %d", &x0[i], &y0[i], &z0[i], &lx, &ly, &lz);
            x1[i] = x0[i] + lx; y1[i] = y0[i] + ly; z1[i] = z0[i] + lz; // 终止位置
            xs[nx++] = x0[i], xs[nx++] = x1[i]; // 离散化准备
            ys[ny++] = y0[i], ys[ny++] = y1[i];
            zs[nz++] = z0[i], zs[nz++] = z1[i];
        }
        discretize(xs, nx); discretize(ys, ny); discretize(zs, nz); // 离散化三维坐标
        memset(color, 0, sizeof(color)); // 初始化
        for (int i=0; i < n; i ++) { // 遍历n个长方体，标记铜块
            int X0 = getId(xs, nx, x0[i]), X1 = getId(xs, nx, x1[i]); // 获取x0[i]在xs中的位置
            int Y0 = getId(ys, ny, y0[i]), Y1 = getId(ys, ny, y1[i]);
            int Z0 = getId(zs, nz, z0[i]), Z1 = getId(zs, nz, z1[i]);
            for (int x=X0; x < X1; x ++) { // (x,y,z)为铜块的左下角坐标
                for (int y=Y0; y < Y1; y ++) 
                    for (int z=Z0; z < Z1; z ++) {
                        color[x][y][z] = 1; // 标记左下角为(x,y,z)的长方体为铜块
                    }
            }
        }
        int v=0, m=0; // 体积，面积
        bfs(v, m); // floodfill类似连通块求解,dfs可能会超时
        printf("%d %d\n", m, v); // 面积，体积
    }
    return 0;
}
```

## 例题6-19 UVA1572 Self-Assembly

### 题目大意

> 锻炼思维的好题，注重分析思路，等价条件转换推理哦

给定n种正方形，每种正方形有4条边，每条边有2个字符构成，包含以下两种模式：

+ 第一个为`A-Z`的大写字母，第二个为`+/-`，如`A+或Z-`
+ `00`

当两条边的第一个字符相同，而第二个字符相反时，两边可相连，`00`不可与任何边相连。

现假设每种正方形无限供应，问是否存在无限拼接图像？

### 思路分析

一拿到题目，毫无头绪，但可以知道它是一个判定性问题，即只需回答`是/否`。

而细看要求，要求判定是否存在**无限延展**的图像，若是存在的话，计算机是没法直接构造出无限的图像的，那么它在暗示我们肯定可以找到一个判定无限的等价条件（类似于循环节的寻找，比如循环小数[UVA202](https://blog.csdn.net/qq_40738840/article/details/104174805)和死循环判定[UVA12108](https://blog.csdn.net/qq_40738840/article/details/104166982)）

按着循环节思路继续分析下去，发现既然是图像，那么能不能用图论方式解决？

+ **尝试1**：将正方形当成顶点，遍历查找可用正方形判断是否有能够连接的。但存在一个致命问题，可用正方形个数无数，组合方式爆炸，除非我能穷举每种情况，才能证明它不存在无限的情况，又绕回了思路分析的源点
+ **尝试2**：将每个正方形的边当成顶点，将正方形作为沟通各个点的边（这里需要一点想象力，和直觉违背），若通过以上方式构建的图存在有向环（循环节），说明存在无限的可能。举个构建图的例子：

```cpp
图一共有A-Z(+/-)52个顶点

输入：K+K-Q+Q-
对于边K+，构造出一点顶点K1，可想而知，只有另一个正方形的边为K-时才能与K+相邻，间接与剩余的3条边相邻，转换为图即是K-这个点能单向到达K-，Q+，Q-这3个点。
> 思考：想想为何不构造K+到K-的边？

同理，对于边K-，构造顶点K+到K+，Q+，Q-单向边
对于边Q+，构造顶点Q-到K+，K-，Q-的单向边
对于边Q-，构造顶点Q+到K+，K-，Q+的单向边

```

至此，思路基本明了，将复杂问题转换为有向图的有向环判断问题，有两种思路处理有向环，可以说图的算法核心就两种：bfs和dfs。这里也一样

+ 拓扑排序（bfs）：拓扑排序过程中计算出队的顶点个数，若不为52，说明存在有向环
+ dfs标记法：关键在于访问状态设计，用`0：违访问, -1：当前正在访问, 1：已访问`来标记状态，在遍历过程中碰到-1的状态，表示遇到环。以下为二者对**求环问题的对比**：

| 对比项目\处理方法 | bfs（拓扑排序） | dfs（活用标记)                |
| ----------------- | --------------- | ----------------------------- |
| 适用性            | 有向图          | 任意图                        |
| 打印环            | 否              | 能                            |
| 效率              | 高              | 低（递归用栈消耗大，防止爆栈) |

### 算法设计

为了便于处理`A+和A-`的转换关系，定义以下转换函数（类似**哈希函数**），令二者处于相邻位置，到真正访问与1异或即可完成变换，例如`ID(A+)=0,ID(A-)=1`，那么将`ID(A+)^1=1`即可得到`ID(A-)`

```cpp
int getId(char c1, char c2) { // 获取字符节点的编号
    return (c1 - 'A')*2 + ((c2 == '+') ? 0 : 1); // 注意?:优先级很低，要用括号
}
```

图用邻接表方式存储，若是**用dfs方式判环，必须注意去除重复邻边**，bfs方式不影响

其余细节参见详细的代码注释，以下给出两种思路的AC代码（二者仅判环过程不同，其余均一致）

### AC代码（C++11）

#### DFS（标记活用）

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<set<int> > adj; // 邻接表，注意用set存储去重
int vis[52]={0}; // 标记访问数组
int getId(char c1, char c2) { // 获取字符节点的编号
    return (c1 - 'A')*2 + ((c2 == '+') ? 0 : 1); // 注意?:优先级很低，要用括号
}
void connect(char a1, char a2, char b1, char b2) { // 参数分别表示两点的第一二个字符
    if (a1 == '0' || b1 == '0') return; // 任意一点为0均不连接
    adj[getId(a1,a2)^1].insert(getId(b1,b2)); // 有向图构建；异或含义-> (B+)^1=B-
}
bool dfs(int u) { // 判断以顶点u开始是否存在有向图
    vis[u] = -1; // 当前遍历的标记
    for (int v : adj[u]) // 邻边
        if (vis[v] == -1 || (vis[v] == 0 && dfs(v))) return true; // 碰见当前已访问节点，表示存在有向环
    vis[u] = 1; // 回溯时标记为1，表示已访问过，必须在return false之前
    return false; // 到此处表示当前连通块不存在有向环
}
bool find_cycle() { // 检查图是否存在有向环
    memset(vis, 0, sizeof(vis)); // 初始化为0，表示未访问
    for (int i=0; i < 52; i ++) // 遍历所有连通块
        if (vis[i] == 0 && dfs(i)) return true; // 存在一个环
    return false;
}
int main() {
    int n; string s;
    while (cin >>n) {
        adj.clear(); adj.resize(52); // 初始化
        for (int i=0; i < n; i ++) {
            cin >>s;
            for (int i=0; i < 4; i ++) { // 考虑旋转翻转
                for (int j=0; j < 4; j ++)
                    if (i != j) connect(s[i*2],s[i*2+1],s[j*2],s[j*2+1]); // 构建有向图
            }
        }
        printf("%s\n", !find_cycle() ? "bounded" : "unbounded");
    }
    return 0;
}
```

#### BFS（拓扑排序）

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<vector<int> > adj; // 邻接表
int getId(char c1, char c2) { // 获取字符节点的编号
    return (c1 - 'A')*2 + ((c2 == '+') ? 0 : 1); // 注意?:优先级很低，要用括号
}
void connect(char a1, char a2, char b1, char b2) { // 参数分别表示两点的第一二个字符
    if (a1 == '0' || b1 == '0') return; // 任意一点为0均不连接
    adj[getId(a1,a2)^1].push_back(getId(b1,b2)); // 有向图构建；异或含义-> (B+)^1=B-
}
bool bfs() { // 拓扑排序检测是否存在有向环
    int indegree[52]={0}, num=0; // 访问数组, 入度表,入队计算
    for (int i=0; i < 52; i ++) 
        for (auto v : adj[i]) indegree[v] ++; // 入度计算
    queue<int> q;
    for (int i=0; i < 52; i ++) if (indegree[i] == 0) q.push(i); // 队列初始化
    while (!q.empty()) {
        int u=q.front(); q.pop(); num ++; // 统计出队个数
        for (int v : adj[u]) {
            indegree[v] --; // 更新入度表
            if (indegree[v] == 0) q.push(v); // 入度=0则进队
        }
    }
    return num == 52; // 不存在有向环num=52
}
int main() {
    int n; string s;
    while (cin >>n) {
        adj.clear(); adj.resize(52); // 初始化
        for (int i=0; i < n; i ++) {
            cin >>s;
            for (int i=0; i < 4; i ++) { // 考虑旋转翻转
                for (int j=0; j < 4; j ++)
                    if (i != j) connect(s[i*2],s[i*2+1],s[j*2],s[j*2+1]); // 构建有向图
            }
        }
        printf("%s\n", bfs() ? "bounded" : "unbounded");
    }
    return 0;
}
```

## 例题6-20 UVA1599 Ideal Path

### 题目大意

给定一个n个顶点，m条边的无向图，每条边有颜色值（长度均为1），求出起点到终点的最短路径（颜色值表示），若存在多解，则输出路径中颜色值字典序最小者。（注意**重边，自环**）

### 思路分析

本题有两个条件：最短+字典序最小

最短路用bfs可轻易解决，但字典序稍微棘手些，不过我们可以借用**控制变量法**，先从终点逆向bfs求出到每一点的距离，此时再从起点bfs，若下一个点v的距离与当前点u距离相差1，说明走点v一定可以到达终点（并且最短），这时候就可以从所有候选点钟选出颜色值最小的加入队列。

本质就是做两次bfs，从终点开始的bfs保证了**最短可达**的条件，从起点开始保证**字典序最小**条件

### 算法设计

本题数据量很大，只能采用邻接表存储图，为了进一步提高效率，将边统一缓存在`edge`数组中，数组下标表示边的编号，在邻接表中只存储边的编号即可，提高索引访问速度，避免超时

```cpp
struct Edge { // 边
    int u, v, c;
    Edge(int _u, int _v, int _c) : u(_u), v(_v), c(_c) {} // 默认构造函数
};
vector<Edge> edge; // 边的缓存，数组下标作为编号
vector<int> G[maxn]; // 邻接表存图，边用编号表示，提高效率；
```

同时，养成bfs的好习惯，在**顶点入队时立刻标记为已访问**，避免同一顶点反复入队，照成资源浪费，况且本题还存在重边，更需注意该细节处理

### 注意点

+ 输出路径时最后一个元素后无空格
+ 注意顶点从0还是1开始
+ 变量使用前注意初始化，其中，能用普通数组的尽量不用stl容器，能用memset尽量不用fill，原始的东西效率较高，但memset只能初始化为0或-1，因为他是对一段内存的位赋值

### AC代码（C++11，双向bfs，边缓存优化）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100001; // 最大顶点数
struct Edge { // 边
    int u, v, c;
    Edge(int _u, int _v, int _c) : u(_u), v(_v), c(_c) {} // 默认构造函数
};
vector<Edge> edge; // 边的缓存，数组下标作为编号
vector<int> G[maxn]; // 邻接表存图，边用编号表示，提高效率；
int n, m, a, b, c;
int d[maxn], vis[maxn]; // d:终点到各个点的距离（层次）；vis：访问数组
void revBfs() { // 从终点开始遍历，计算到每个点的距离
    memset(d, 0, sizeof(d)); memset(vis, 0, sizeof(vis)); // 初始化
    queue<int> q;
    q.push(n-1); vis[n-1] = 1; // 终点入队
    while (!q.empty()) {
        int u = q.front(); q.pop(); // 顶点出队
        for (int e : G[u]) { // 每条邻边
            int v = (u == edge[e].u) ? edge[e].v : edge[e].u;
            if (vis[v] == 0) { // 未访问
                d[v] = d[u] + 1; // 距离/层次更新
                q.push(v);
                vis[v] = 1; // 标记访问
            }
        }
    }
}
void bfs() { // 从起点开始bfs，记录字典序最小的路径
    printf("%d\n", d[0]); // 最短距离
    memset(vis, 0, sizeof(vis)); // 初始化
    vector<int> next{0}, ans;
    for (int i=0; i < d[0]; i ++) { // 分层遍历
        int minColor=0x3fffffff; // 最小颜色值
        for (int u : next) // 该层顶点（找出本层到下一层的最小颜色值）
            for (int e : G[u]) { // 所有边
                int v = (u == edge[e].u) ? edge[e].v : edge[e].u; // 确定下一个顶点
                if (d[u] == d[v]+1 && edge[e].c < minColor) minColor = edge[e].c; // 找出可达终点的最小颜色边  
            }
        ans.push_back(minColor); // 存储最小颜色
        vector<int> tnext; // 临时存储
        for (int u : next) // 将本层到下一层颜色值满足最小的点加入下一轮next
            for (int e : G[u]) {
                int v = (u == edge[e].u) ? edge[e].v : edge[e].u;
                if (d[u] == d[v]+1 && vis[v] == 0 && edge[e].c == minColor) {
                    tnext.push_back(v);
                    vis[v] = 1;
                }
            }
        next = tnext; // 更新next数组
    }
    for (int i=0; i < ans.size(); i ++) printf("%d%s", ans[i], i == ans.size()-1 ? "\n" : " ");
}
int main() {
    while (scanf("%d %d", &n, &m) == 2) {
        edge.clear(); fill(G, G+maxn, vector<int>{}); // 初始化
        while (m --) {
            scanf("%d %d %d", &a, &b, &c);
            if (a == b) continue; // 处理自环
            G[a-1].push_back(edge.size()); // 无向图，从0开始存储
            G[b-1].push_back(edge.size());
            edge.push_back({a-1,b-1,c}); // 边缓存
        }
        revBfs();
        bfs();
    }
    return 0;
}
```

## 例题6-21 UVA506 System Dependencies

### 题目大意

> 把每个命令要做的事理清，代码很简单
>
> 本题的问题背景极有实际意义，例如
>
> + Linux下各种包管理器
> + 开发应用程序时配置管理，如springboot框架等

给定组件的依赖关系，根据命令输出相应信息，四种命令如下：

+ `DEPEND item1 item2 [item3 ...]` :item1 依赖于item2 (and item3 ...)
+ `INSTALL item1 `：安装 item1 和它的依赖（若有多个依赖则按照输入依赖的顺序处理）
+ `REMOVE item1`：移除item1，和它的依赖（当且仅当它的依赖为**隐式安装**且**此时不再被其它组件依赖**；若有多个依赖则按照输入依赖的顺序处理）
+ `LIST`：按安装顺序输出已安装的组件

其中**install item成功**的项目称作显示安装

### 算法设计

为了提高效率，将字符串缓存与数组中，并用map存储相应编号，后续所有操作均存储id即可

```cpp
map<string, int> idMp; // 名字->id
vector<string> name; // 组件名字缓存
```

为了便于处理依赖关系，定义`before和after`，其中`before[i]`表示i依赖的前置组件，`after[i]`表示依赖于i的后置组件；定义`status`区分安装状态；`installed`仅仅是为了List命令服务

```cpp
map<int,vector<int> > before, after; // 依赖的项目，被项目依赖
vector<int> installed; // 已安装列表
int status[maxn]={0}; // 0：未安装；1：已显示安装；2：隐式安装
```

至于安装和删除都可以递归进行（输出顺序不同，对应为后序和先序），注意只有**显示删除命令才可以删除显式安装**

### 注意点

+ 样例输出中倒数第二个删除命令的`Removing HTML和 Removing TCPIP`顺序反了
+ 注意安装时已存在，删除时不存在的情况

### AC代码（C++11，字符串处理，命令处理）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=10010; // 最大点数
map<string, int> idMp; // 名字->id
vector<string> name; // 组件名字缓存
map<int,vector<int> > before, after; // 依赖的项目，被项目依赖
vector<int> installed; // 已安装列表
int status[maxn]={0}; // 0：未安装；1：已显示安装；2：隐式安装
int getId(string s) { // 手动分配id
    if (idMp.find(s) == idMp.end()) { // 不存在，手动分配
        idMp[s] = name.size();
        name.push_back(s);
    }
    return idMp[s]; // 已存在，直接返回
}
void List() { // 按安装顺序打印已安装列表
    for (auto s : installed) printf("   %s\n", name[s].c_str());
}
void Install(int i, bool isTop) { // 递归安装
    if (status[i] != 0 && isTop) printf("   %s is already installed.\n", name[i].c_str()); // 已安装
    if (status[i] == 0) { // 未安装
        for (int j : before[i]) Install(j, false); // 递归安装前置依赖
        printf("   Installing %s\n", name[i].c_str());
        status[i] = (isTop ? 1 : 2); // 顶部为显示依赖，其余为隐式依赖
        installed.push_back(i); // 存于安装列表
    } 
}
bool isNeed(int i) { // 判断i是否被依赖
    for (int j : after[i]) if (status[j] != 0) return true; // 遍历后置节点
    return false;
}
void Remove(int r, bool isTop) { // 递归移除
    if (status[r] == 0 && isTop) printf("   %s is not installed.\n", name[r].c_str()); // 未安装
    if (status[r] != 0 && isTop && isNeed(r)) printf("   %s is still needed.\n", name[r].c_str()); // 存在依赖
    if (status[r] != 0 && !isNeed(r)) { // 不被需要
        printf("   Removing %s\n", name[r].c_str());
        status[r] = 0; // 状态置0，未安装
        installed.erase(find(installed.begin(), installed.end(), r)); // 删除安装列表中相应信息
        for (int j : before[r]) if (status[j] == 2) Remove(j, false); // 仅删除隐式依赖
    }
}
int main() {
    string line, cmd, sa, sb;
    while (getline(cin, line)) {
        cout <<line <<endl; // 输出原命令
        if (line[0] == 'E') { // 初始化数据结构
            idMp.clear(); name.clear(); before.clear(); after.clear(); installed.clear();
            memset(status, 0, sizeof(status));
            continue; // 进入下一组数据输入
        }
        stringstream input(line); // 流分割
        input >>cmd; // 命令
        if (cmd[0] == 'L') List(); // 显示已安装列表
        else {
            input >>sa;
            if (cmd[0] == 'D') { // 增加依赖
                while (input >>sb) {
                    before[getId(sa)].push_back(getId(sb)); // sa依赖于sb
                    after[getId(sb)].push_back(getId(sa)); // sb被sa依赖
                }
            }
            else if (cmd[0] == 'I') Install(getId(sa), true); // 安装
            else if (cmd[0] == 'R') Remove(getId(sa), true); // 删除
        }
    }
    return 0;
}
```

## 例题6-22 UVA11853 Paintball

### 题目大意

给定边长为1000的正方形，左下角和右上角坐标分别为`(0,0)和(1000,1000)`，先已知若干圆的圆心坐标和半径，问能否从正方形左侧不穿过任何圆到达右侧？若存在多个出入口，则输出靠近上方的点。

**注意在仅仅在圆的内部才算穿过，边界不算**

### 思路分析

看起来无从下手，因为点坐标是无限多的，若是直接寻找一条从左侧到右侧的路径，就会陷入无限状态的死局。又碰到了这种无限的情况，类似[UVA12171](https://blog.csdn.net/qq_40738840/article/details/104403108)，于是考虑能够离散化处理，但圆这图形不像长方形，范围难以处理，只好放弃。在细看题目

```cpp
问题1：什么情况一定无解？
答案1：从上边界到下边界存在若干连续的相交圆
```

仔细分析题目条件，若那么把圆看成顶点，相交的圆存在边，与边相交则可在边上任取一点作为顶点相连。若是能从左穿到右，那么从上边界一定无法到达下边界，即转换为连通性判定问题

以上思想本质是逆向思维，将空白处和圆对调来考虑问题。

因为初始想法是在空白处找到一条通路，但其存在无限点问题，此时若转为考虑圆，首先圆个数是有限的（类似离散化），解决无线点问题，其次将问题转换为连通性问题，可以回答判定性问题1。

```cpp
问题2：如何找到左右边界的入出口？
答案2：在所有从上边界开始的连通块中，取与左右边界交点最南的点
```

这听起来觉得有些荒谬，但是，此时我们已经能判断存在一条从左到右的通路，那么我们大可以忽略内部细节，将路径看成一个黑盒，只注重于它的起点和终点（因为只要垂直方向不被完全阻断，那么无孔不入的你就可以通过）

建议多画几个图看看，比如下图（插图容易丢，凑合着看：），外围表示正方形，内部有两个从顶部开始的连通块，`|和*`分别表示连通块A,B，可以比较容易看出，A与左边界交点更南，因此取它的交点，依次类推，推广到多个连通块情况。聪明的你，利用对称法则，肯定可以解决右侧边界的情况。

```cpp
|------------------|
|		|	*	   |
|	  /     *      |
|*	/ *  *  *      |
|- /               |
|                  |
|------------------|
```

因此做个总结，将圆看成顶点，相交的圆存在无向边，加入坐标信息后，对于**每个与上边界相交的圆**，以其为起点进行dfs遍历，若能到达与下边界相交的圆，则表示无解；在以上dfs过程中，经过的每个点都是连通块的一部分，此时取其中与左右边界交点的最南端点，即为答案。

### 注意点

+ 两圆相交则表示存在边（不同于相切），本题相交表示坐标间关系都是严格大于或小于，不可取等

### AC代码（C++11，条件转换，连通块dfs）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define SQU(x) ((x)*(x)) // 平方宏，注意都要加括号
const int maxn=1010; // 最大圆数量
int n, vis[maxn]={0}; // 访问数组
double x[maxn], y[maxn], r[maxn], ansl, ansr; // 坐标(x,y);r为半径;左边界最小点，右边界最小点
bool isIntersect(int c1, int c2) { // 判断两个圆是否相交：圆心距 < (r1+r2)  
    return SQU(x[c1]-x[c2]) + SQU(y[c1]-y[c2]) < SQU(r[c1]+r[c2]);
}
void calLR (int c) { // 计算每个连通块与左右边界最南处交点
    if (x[c] < r[c]) { // 与左边界相交
        double t = y[c] - sqrt(SQU(r[c]) - SQU(x[c]));
        if (t < ansl) ansl = t;  
    }
    if (x[c] + r[c] > 1000) { // 与右边界相交
        double t = y[c] - sqrt(SQU(r[c]) - SQU(1000-x[c]));
        if (t < ansr) ansr = t;
    }
}
bool dfs(int c) { // 判断能否从北边界走到南边界
    vis[c] = 1; // 标记为已访问
    if (y[c] < r[c]) return true; // 不取等，碰到南边界，即直线y=0
    for (int i=0; i < n; i ++) if (vis[i]==0 && isIntersect(c,i) && dfs(i)) return true; // 遍历连通块
    calLR(c); // 计算左右边界
    return false; // 到这里说明
}
int main() {
    while (scanf("%d", &n) == 1) {
        for (int i=0; i < n; i ++) scanf("%lf%lf%lf", &x[i], &y[i], &r[i]);
        memset(vis, 0, sizeof(vis)); ansl = ansr = 1000.0; // 初始化
        bool isWin=true;
        for (int i=0; i < n; i ++) // 遍历n个圆
            if (y[i]+r[i] > 1000 && dfs(i)) { // 与上边界相交且能走到下边界
                isWin = false;
                break;
            }
        if (isWin) printf("0.00 %.2lf 1000.00 %.2lf\n", ansl, ansr);
        else puts("IMPOSSIBLE");
    }
    return 0;
}
```

